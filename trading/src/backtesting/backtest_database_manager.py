#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Î∞±ÌÖåÏä§Ìä∏ Í≤∞Í≥º Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Í¥ÄÎ¶¨ Î™®Îìà
MySQL Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§Ïóê Î∞±ÌÖåÏä§Ìä∏ Í≤∞Í≥ºÎ•º Ï†ÄÏû•ÌïòÍ≥† Í¥ÄÎ¶¨Ìï©ÎãàÎã§.
"""

import mysql.connector
import json
import os
from datetime import datetime, date
from typing import Dict, Any, Optional
import traceback

from src.config.ea_teb_config import (
    DEVICE,
    TARGET_SYMBOLS,
    LOGGER,
    WINDOW_SIZE,
    INITIAL_BALANCE,
    TRANSACTION_FEE_PERCENT
)

class BacktestDatabaseManager:
    """
    Î∞±ÌÖåÏä§Ìä∏ Í≤∞Í≥ºÎ•º MySQL Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§Ïóê Ï†ÄÏû•ÌïòÍ≥† Í¥ÄÎ¶¨ÌïòÎäî ÌÅ¥ÎûòÏä§
    """

    def __init__(self, host: str, database: str, user: str, password: str, port: int = 3306):
        """
        MySQL Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ Ï¥àÍ∏∞Ìôî

        Args:
            host: MySQL ÏÑúÎ≤Ñ Ìò∏Ïä§Ìä∏
            database: Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïù¥Î¶Ñ
            user: ÏÇ¨Ïö©ÏûêÎ™Ö
            password: ÎπÑÎ∞ÄÎ≤àÌò∏
            port: Ìè¨Ìä∏ Î≤àÌò∏ (Í∏∞Î≥∏Í∞í: 3306)
        """
        self.connection_config = {
            'host': host,
            'database': database,
            'user': user,
            'password': password,
            'port': port,
            'charset': 'utf8mb4',
            'autocommit': False
        }
        self.connection = None

    def connect(self) -> bool:
        """
        Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞

        Returns:
            bool: Ïó∞Í≤∞ ÏÑ±Í≥µ Ïó¨Î∂Ä
        """
        try:
            self.connection = mysql.connector.connect(**self.connection_config)
            print("‚úÖ MySQL Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§Ïóê ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Ïó∞Í≤∞ÎêòÏóàÏäµÎãàÎã§.")
            return True
        except mysql.connector.Error as error:
            print(f"‚ùå Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ Ïã§Ìå®: {error}")
            return False

    def disconnect(self) -> None:
        """Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ Ï¢ÖÎ£å"""
        if self.connection and self.connection.is_connected():
            self.connection.close()
            print("üìã MySQL Ïó∞Í≤∞Ïù¥ Ï¢ÖÎ£åÎêòÏóàÏäµÎãàÎã§.")

    def create_tables_if_not_exists(self) -> bool:
        """
        Í∏∞Ï°¥ ÌÖåÏù¥Î∏î Íµ¨Ï°∞Ïóê ÎßûÍ≤å ÌôïÏù∏ (ÌÖåÏù¥Î∏î ÏÉùÏÑ±ÌïòÏßÄ ÏïäÏùå)

        Returns:
            bool: ÌÖåÏù¥Î∏î ÌôïÏù∏ ÏÑ±Í≥µ Ïó¨Î∂Ä
        """
        if not self.connection:
            print("‚ùå Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§Í∞Ä Ïó∞Í≤∞ÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.")
            return False

        try:
            cursor = self.connection.cursor()

            print("üîÑ Í∏∞Ï°¥ ÌÖåÏù¥Î∏î ÌôïÏù∏ Ï§ë...")
            
            # ÌÖåÏù¥Î∏î Ï°¥Ïû¨ Ïó¨Î∂Ä ÌôïÏù∏
            cursor.execute("SHOW TABLES LIKE 'backtest_results'")
            table_exists = cursor.fetchone() is not None
            
            if table_exists:
                print("üìã Í∏∞Ï°¥ backtest_results ÌÖåÏù¥Î∏î Î∞úÍ≤¨Îê®.")
                cursor.execute("DESCRIBE backtest_results")
                columns = [row[0] for row in cursor.fetchall()]
                print(f"üìã backtest_results ÌÖåÏù¥Î∏î Ïª¨Îüº: {columns}")
                
                # ÌïÑÏàò Ïª¨Îüº ÌôïÏù∏
                required_columns = [
                    'id', 'symbol', 'model_id', 'backtest_date', 'start_date', 'end_date',
                    'initial_balance', 'final_balance', 'total_return', 'win_rate', 
                    'total_trades', 'annualized_return', 'sharpe_ratio', 'max_drawdown', 
                    'profit_factor', 'parameters'
                ]
                
                missing_columns = [col for col in required_columns if col not in columns]
                if missing_columns:
                    print(f"‚ö†Ô∏è  ÎàÑÎùΩÎêú Ïª¨Îüº: {missing_columns}")
                    return False
                else:
                    print("‚úÖ Î™®Îì† ÌïÑÏàò Ïª¨ÎüºÏù¥ Ï°¥Ïû¨Ìï©ÎãàÎã§.")
            else:
                print("‚ùå backtest_results ÌÖåÏù¥Î∏îÏù¥ Ï°¥Ïû¨ÌïòÏßÄ ÏïäÏäµÎãàÎã§.")
                print("üí° Îã§Ïùå SQLÎ°ú ÌÖåÏù¥Î∏îÏùÑ ÏÉùÏÑ±ÌïòÏÑ∏Ïöî:")
                print("""
CREATE TABLE backtest_results (
    id INT AUTO_INCREMENT PRIMARY KEY,
    symbol VARCHAR(50) NOT NULL,
    model_id VARCHAR(50) NOT NULL,
    backtest_date DATE NOT NULL,
    start_date DATETIME,
    end_date DATETIME,
    initial_balance DECIMAL(15,2) NOT NULL,
    final_balance DECIMAL(15,2) NOT NULL,
    total_return DECIMAL(15,2) NOT NULL,
    win_rate DECIMAL(10,6),
    total_trades INT DEFAULT 0,
    annualized_return DECIMAL(10,6),
    sharpe_ratio DECIMAL(10,6),
    max_drawdown DECIMAL(10,6),
    profit_factor DECIMAL(10,6),
    parameters JSON
);
                """)
                return False
            
            cursor.close()
            return True

        except mysql.connector.Error as error:
            print(f"‚ùå ÌÖåÏù¥Î∏î ÌôïÏù∏ Ï§ë Ïò§Î•ò: {error}")
            return False

    def convert_backtest_results_to_db_format(self, results: Dict[str, Any], metrics: Dict[str, Any],
                                               symbol: str, model_path: str, data_type: str = 'test',
                                               backtest_start_time=None, backtest_end_time=None) -> Dict[str, Any]:
        """
        Î∞±ÌÖåÏä§Ìä∏ Í≤∞Í≥ºÎ•º Í∏∞Ï°¥ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï†ÄÏû• ÌòïÏãùÏúºÎ°ú Î≥ÄÌôò (Í∏∞Ï°¥ ÌÖåÏù¥Î∏î Íµ¨Ï°∞Ïóê ÎßûÏ∂§)

        Args:
            results: Î∞±ÌÖåÏä§Ìä∏ Í≤∞Í≥º ÎîïÏÖîÎÑàÎ¶¨
            metrics: ÏÑ±Îä• ÏßÄÌëú ÎîïÏÖîÎÑàÎ¶¨
            symbol: Ï£ºÏãù Ïã¨Î≥º
            model_path: Î™®Îç∏ Í≤ΩÎ°ú
            data_type: Îç∞Ïù¥ÌÑ∞ ÌÉÄÏûÖ ('train', 'valid', 'test')
            backtest_start_time: Î∞±ÌÖåÏä§Ìä∏ ÏãúÏûë ÏãúÍ∞Ñ
            backtest_end_time: Î∞±ÌÖåÏä§Ìä∏ Ï¢ÖÎ£å ÏãúÍ∞Ñ

        Returns:
            Dict: Í∏∞Ï°¥ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï†ÄÏû•Ïö© ÌòïÏãù
        """
        try:
            # ÎÇ†Ïßú/ÏãúÍ∞Ñ Ï†ïÎ≥¥ (Ïã§Ï†ú Î∞±ÌÖåÏä§ÌåÖ ÏãúÍ∞Ñ ÏÇ¨Ïö©)
            if backtest_start_time and backtest_end_time:
                start_date = backtest_start_time  # Ïã§Ï†ú Î∞±ÌÖåÏä§ÌåÖ ÏãúÏûë ÏãúÍ∞Ñ
                end_date = backtest_end_time      # Ïã§Ï†ú Î∞±ÌÖåÏä§ÌåÖ Ï¢ÖÎ£å ÏãúÍ∞Ñ
                backtest_date = backtest_start_time.date()  # Î∞±ÌÖåÏä§ÌåÖ ÏãúÏûë ÎÇ†Ïßú
            else:
                # Î∞±ÏóÖ: ÌòÑÏû¨ ÏãúÍ∞Ñ ÏÇ¨Ïö© (Í∏∞Ï°¥ Î∞©Ïãù)
                now = datetime.now()
                start_date = now
                end_date = now
                backtest_date = now.date()
            
            # Í∏∞Î≥∏ Í∞íÎì§
            initial_balance = results.get('initial_portfolio_value', INITIAL_BALANCE)
            final_balance = results.get('final_portfolio_value', initial_balance)
            
            # Î©îÌä∏Î¶≠Ïä§ÏóêÏÑú Í∞íÎì§ Ï∂îÏ∂ú (Í∏∞Î≥∏Í∞í ÏÑ§Ï†ï)
            total_return = metrics.get('total_return', 0.0)
            annualized_return = metrics.get('annual_return', 0.0)
            sharpe_ratio = metrics.get('sharpe_ratio', 0.0)
            max_drawdown = metrics.get('max_drawdown', 0.0)
            win_rate = metrics.get('win_rate', 0.0)
            total_trades = metrics.get('total_trades', 0)
            
            # Profit Factor Í≥ÑÏÇ∞
            profit_factor = self._calculate_profit_factor(results)
            
            # Î™®Îç∏ ÌÉÄÏûÖ Í∞êÏßÄ (Î™®Îç∏ Í≤ΩÎ°úÏóêÏÑú Ï∂îÏ∂ú)
            model_type = self._detect_model_type(model_path)
            
            # Model ID ÏÉùÏÑ± (ÏÉàÎ°úÏö¥ ÌòïÏãù: ÎÇ†Ïßú_Î™®Îç∏ÌÉÄÏûÖ_ÏàòÏùµÎ•†)
            date_str = backtest_date.strftime("%Y%m%d")
            return_str = f"{total_return:.2f}"
            model_id = f"{date_str}_{model_type}_{return_str}"
            
            # Parameters JSON ÏÉùÏÑ± (Î™®Îç∏ Í≤ΩÎ°ú Î∞è ÏãúÍ∞Ñ Ï†ïÎ≥¥ Ìè¨Ìï®)
            parameters = {
                'model_path': model_path,
                'data_type': data_type,
                'model_type': model_type,  # Î™®Îç∏ ÌÉÄÏûÖ Ï∂îÍ∞Ä
                'window_size': 30,  # Í∏∞Î≥∏Í∞í
                'initial_balance': initial_balance,
                'algorithm': 'sac',
                'total_steps': metrics.get('total_steps', 0),
                'backtest_start_time': start_date.isoformat(),
                'backtest_end_time': end_date.isoformat(),
                'backtest_duration_seconds': (end_date - start_date).total_seconds() if backtest_start_time and backtest_end_time else 0
            }
            
            # Í∏∞Ï°¥ ÌÖåÏù¥Î∏î Íµ¨Ï°∞Ïóê ÎßûÎäî Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
            db_data = {
                'symbol': symbol,
                'model_id': model_id,
                'backtest_date': backtest_date,
                'start_date': start_date,  # Ïã§Ï†ú Î∞±ÌÖåÏä§ÌåÖ ÏãúÏûë ÏãúÍ∞Ñ
                'end_date': end_date,      # Ïã§Ï†ú Î∞±ÌÖåÏä§ÌåÖ Ï¢ÖÎ£å ÏãúÍ∞Ñ
                'initial_balance': float(initial_balance),
                'final_balance': float(final_balance),
                'total_return': float(total_return),
                'win_rate': float(win_rate / 100.0) if win_rate > 1.0 else float(win_rate),  # ÎπÑÏú®Î°ú Î≥ÄÌôò
                'total_trades': int(total_trades),
                'annualized_return': float(annualized_return / 100.0) if annualized_return > 1.0 else float(annualized_return),  # ÎπÑÏú®Î°ú Î≥ÄÌôò
                'sharpe_ratio': float(sharpe_ratio),
                'max_drawdown': float(abs(max_drawdown) / 100.0) if abs(max_drawdown) > 1.0 else float(abs(max_drawdown)),  # ÎπÑÏú®Î°ú Î≥ÄÌôò
                'profit_factor': float(profit_factor),
                'parameters': parameters
            }
            
            return db_data
            
        except Exception as e:
            print(f"‚ùå Îç∞Ïù¥ÌÑ∞ Î≥ÄÌôò Ï§ë Ïò§Î•ò: {str(e)}")
            # Í∏∞Î≥∏ Îç∞Ïù¥ÌÑ∞ Î∞òÌôò
            now = datetime.now()
            return {
                'symbol': symbol,
                'model_id': f"{now.strftime('%Y%m%d')}_unknown_0.00",
                'backtest_date': now.date(),
                'start_date': now,
                'end_date': now,
                'initial_balance': INITIAL_BALANCE,
                'final_balance': INITIAL_BALANCE,
                'total_return': 0.0,
                'win_rate': 0.0,
                'total_trades': 0,
                'annualized_return': 0.0,
                'sharpe_ratio': 0.0,
                'max_drawdown': 0.0,
                'profit_factor': 0.0,
                'parameters': {'model_path': model_path, 'data_type': data_type}
            }

    def _detect_model_type(self, model_path: str) -> str:
        """
        Î™®Îç∏ Í≤ΩÎ°úÏóêÏÑú Î™®Îç∏ ÌÉÄÏûÖ Í∞êÏßÄ
        
        Args:
            model_path: Î™®Îç∏ ÌååÏùº Í≤ΩÎ°ú
            
        Returns:
            str: Î™®Îç∏ ÌÉÄÏûÖ ('mlp', 'cnn', 'lstm', 'transformer')
        """
        try:
            model_name = os.path.basename(model_path.rstrip('/\\')).lower()
            
            # Î™®Îç∏ Ïù¥Î¶ÑÏóêÏÑú ÌÉÄÏûÖ Í∞êÏßÄ
            if 'cnn' in model_name:
                return 'cnn'
            elif 'lstm' in model_name:
                return 'lstm'
            elif 'transformer' in model_name:
                return 'transformer'
            elif 'mlp' in model_name or 'sac_model' in model_name:
                return 'mlp'
            else:
                # Í∏∞Î≥∏Í∞íÏúºÎ°ú mlp Î∞òÌôò
                return 'mlp'
                
        except Exception as e:
            print(f"‚ö†Ô∏è  Î™®Îç∏ ÌÉÄÏûÖ Í∞êÏßÄ Ïã§Ìå®: {e}")
            return 'unknown'

    def _calculate_profit_factor(self, results: Dict[str, Any]) -> float:
        """
        Profit Factor Í≥ÑÏÇ∞ (Ï¥ù Ïù¥Ïùµ / Ï¥ù ÏÜêÏã§)

        Args:
            results: Î∞±ÌÖåÏä§Ìä∏ Í≤∞Í≥º

        Returns:
            float: Profit Factor Í∞í
        """
        try:
            rewards = results.get('rewards', [])
            if not rewards:
                return 0.0

            total_profit = sum(r for r in rewards if r > 0)
            total_loss = abs(sum(r for r in rewards if r < 0))

            if total_loss == 0:
                return float('inf') if total_profit > 0 else 0.0

            return total_profit / total_loss

        except Exception:
            return 0.0

    def insert_backtest_result(self, backtest_data: Dict[str, Any],
                               trade_details: Optional[Dict[str, Any]] = None) -> Optional[int]:
        """
        Î∞±ÌÖåÏä§Ìä∏ Í≤∞Í≥ºÎ•º Í∏∞Ï°¥ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÌÖåÏù¥Î∏îÏóê Ï†ÄÏû•

        Args:
            backtest_data: Î∞±ÌÖåÏä§Ìä∏ Í≤∞Í≥º Îç∞Ïù¥ÌÑ∞
            trade_details: ÏÉÅÏÑ∏ Í±∞Îûò ÎÇ¥Ïó≠ (ÌòÑÏû¨ ÎØ∏ÏÇ¨Ïö©)

        Returns:
            Optional[int]: Ï†ÄÏû•Îêú Î†àÏΩîÎìúÏùò ID (Ïã§Ìå®Ïãú None)
        """
        if not self.connection:
            print("‚ùå Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§Í∞Ä Ïó∞Í≤∞ÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.")
            return None

        try:
            cursor = self.connection.cursor()

            # Í∏∞Ï°¥ ÌÖåÏù¥Î∏î Íµ¨Ï°∞Ïóê ÎßûÎäî INSERT ÏøºÎ¶¨
            insert_query = """
            INSERT INTO backtest_results (
                symbol, model_id, backtest_date, start_date, end_date,
                initial_balance, final_balance, total_return, win_rate, total_trades,
                annualized_return, sharpe_ratio, max_drawdown, profit_factor, parameters
            ) VALUES (
                %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s
            )
            """

            # ÎÇ†Ïßú/ÏãúÍ∞Ñ Ï≤òÎ¶¨
            backtest_date = backtest_data['backtest_date']  # date Í∞ùÏ≤¥
            start_date = backtest_data['start_date']  # datetime Í∞ùÏ≤¥
            end_date = backtest_data['end_date']  # datetime Í∞ùÏ≤¥

            # Îç∞Ïù¥ÌÑ∞ Ï§ÄÎπÑ (Í∏∞Ï°¥ ÌÖåÏù¥Î∏î Íµ¨Ï°∞Ïóê ÎßûÍ≤å)
            values = (
                backtest_data['symbol'],
                backtest_data['model_id'],
                backtest_date,
                start_date,
                end_date,
                float(backtest_data['initial_balance']),
                float(backtest_data['final_balance']),
                float(backtest_data['total_return']),
                float(backtest_data.get('win_rate', 0.0)),
                int(backtest_data.get('total_trades', 0)),
                float(backtest_data.get('annualized_return', 0.0)),
                float(backtest_data.get('sharpe_ratio', 0.0)),
                float(backtest_data.get('max_drawdown', 0.0)),
                float(backtest_data.get('profit_factor', 0.0)),
                json.dumps(backtest_data.get('parameters', {}))
            )

            cursor.execute(insert_query, values)
            backtest_id = cursor.lastrowid

            self.connection.commit()

            print(f"‚úÖ Î∞±ÌÖåÏä§Ìä∏ Í≤∞Í≥ºÍ∞Ä ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§.")
            print(f"   ‚îî‚îÄ Backtest ID: {backtest_id}")
            print(f"   ‚îî‚îÄ Model ID: {backtest_data['model_id']}")
            print(f"   ‚îî‚îÄ Symbol: {backtest_data['symbol']}")
            print(f"   ‚îî‚îÄ Backtest Date: {backtest_date}")
            print(f"   ‚îî‚îÄ Total Return: {backtest_data['total_return']:.4f}%")
            print(f"   ‚îî‚îÄ Win Rate: {backtest_data.get('win_rate', 0.0)*100:.2f}%")
            print(f"   ‚îî‚îÄ Total Trades: {backtest_data.get('total_trades', 0):,}")

            cursor.close()
            return backtest_id

        except mysql.connector.Error as error:
            print(f"‚ùå Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû• Ï§ë MySQL Ïò§Î•ò: {error}")
            if self.connection:
                self.connection.rollback()
            return None
        except Exception as error:
            print(f"‚ùå Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû• Ï§ë ÏòàÏÉÅÏπò Î™ªÌïú Ïò§Î•ò: {error}")
            print(traceback.format_exc())
            if self.connection:
                self.connection.rollback()
            return None

    def check_existing_record(self, model_id: str, symbol: str) -> bool:
        """
        Ïù¥ÎØ∏ Ï°¥Ïû¨ÌïòÎäî Î†àÏΩîÎìúÏù∏ÏßÄ ÌôïÏù∏ (Í∏∞Ï°¥ ÌÖåÏù¥Î∏î Íµ¨Ï°∞Ïóê ÎßûÏ∂§)

        Args:
            model_id: Î™®Îç∏ ID
            symbol: Ï£ºÏãù Ïã¨Î≥º

        Returns:
            bool: Î†àÏΩîÎìú Ï°¥Ïû¨ Ïó¨Î∂Ä
        """
        if not self.connection:
            return False

        try:
            cursor = self.connection.cursor()
            query = """
            SELECT COUNT(*) FROM backtest_results 
            WHERE model_id = %s AND symbol = %s
            """
            cursor.execute(query, (model_id, symbol))
            count = cursor.fetchone()[0]
            cursor.close()
            return count > 0
        except mysql.connector.Error as error:
            print(f"‚ùå Î†àÏΩîÎìú ÌôïÏù∏ Ï§ë Ïò§Î•ò: {error}")
            return False

    def get_performance_summary(self, symbol: str = None, limit: int = 10) -> Optional[list]:
        """
        ÏÑ±Îä• ÏöîÏïΩ Ï†ïÎ≥¥ Ï°∞Ìöå (Í∏∞Ï°¥ ÌÖåÏù¥Î∏î Íµ¨Ï°∞Ïóê ÎßûÏ∂§)

        Args:
            symbol: ÌäπÏ†ï Ïã¨Î≥º ÌïÑÌÑ∞ (ÏÑ†ÌÉùÏÇ¨Ìï≠)
            limit: Ï°∞ÌöåÌï† ÏµúÎåÄ Î†àÏΩîÎìú Ïàò

        Returns:
            Optional[list]: ÏÑ±Îä• ÏöîÏïΩ Î¶¨Ïä§Ìä∏
        """
        if not self.connection:
            return None

        try:
            cursor = self.connection.cursor(dictionary=True)

            if symbol:
                query = """
                SELECT symbol, model_id, backtest_date, total_return, 
                       sharpe_ratio, max_drawdown, total_trades, win_rate
                FROM backtest_results 
                WHERE symbol = %s
                ORDER BY backtest_date DESC, total_return DESC
                LIMIT %s
                """
                cursor.execute(query, (symbol, limit))
            else:
                query = """
                SELECT symbol, model_id, backtest_date, total_return, 
                       sharpe_ratio, max_drawdown, total_trades, win_rate
                FROM backtest_results 
                ORDER BY backtest_date DESC, total_return DESC
                LIMIT %s
                """
                cursor.execute(query, (limit,))

            results = cursor.fetchall()
            cursor.close()
            return results

        except mysql.connector.Error as error:
            print(f"‚ùå ÏÑ±Îä• ÏöîÏïΩ Ï°∞Ìöå Ï§ë Ïò§Î•ò: {error}")
            return None

    def display_summary(self, backtest_data: Dict[str, Any]) -> None:
        """
        Î∞±ÌÖåÏä§Ìä∏ Í≤∞Í≥º ÏöîÏïΩ Ï†ïÎ≥¥ Ï∂úÎ†• (Í∏∞Ï°¥ ÌÖåÏù¥Î∏î Íµ¨Ï°∞Ïóê ÎßûÏ∂§)

        Args:
            backtest_data: Î∞±ÌÖåÏä§Ìä∏ Í≤∞Í≥º Îç∞Ïù¥ÌÑ∞
        """
        print("\n" + "=" * 50)
        print("üìä Î∞±ÌÖåÏä§Ìä∏ Í≤∞Í≥º ÏöîÏïΩ")
        print("=" * 50)
        print(f"üìà Ïã¨Î≥º: {backtest_data.get('symbol', 'N/A')}")
        print(f"ü§ñ Î™®Îç∏ ID: {backtest_data.get('model_id', 'N/A')}")
        print(f"üìÖ Î∞±ÌÖåÏä§Ìä∏ ÎÇ†Ïßú: {backtest_data.get('backtest_date', 'N/A')}")
        
        # ÏãúÏûë/Ï¢ÖÎ£å ÏãúÍ∞Ñ Ï†ïÎ≥¥ Ï∂îÍ∞Ä
        start_time = backtest_data.get('start_date')
        end_time = backtest_data.get('end_date')
        if start_time and end_time:
            print(f"‚è∞ ÏãúÏûë ÏãúÍ∞Å: {start_time.strftime('%Y-%m-%d %H:%M:%S')}")
            print(f"‚è∞ Ï¢ÖÎ£å ÏãúÍ∞Å: {end_time.strftime('%Y-%m-%d %H:%M:%S')}")
            
            # ÏÜåÏöî ÏãúÍ∞Ñ Í≥ÑÏÇ∞
            duration = end_time - start_time
            duration_str = str(duration).split('.')[0]  # ÎßàÏù¥ÌÅ¨Î°úÏ¥à Ï†úÍ±∞
            print(f"‚è±Ô∏è  ÏÜåÏöî ÏãúÍ∞Ñ: {duration_str}")
        
        print(f"üí∞ Ï¥àÍ∏∞ ÏûêÏÇ∞: ${backtest_data.get('initial_balance', 0):,.2f}")
        print(f"üíµ ÏµúÏ¢Ö ÏûêÏÇ∞: ${backtest_data.get('final_balance', 0):,.2f}")
        print(f"üìà Ï¥ù ÏàòÏùµÎ•†: {backtest_data.get('total_return', 0):.2f}%")
        print(f"üìä Ïó∞Í∞Ñ ÏàòÏùµÎ•†: {backtest_data.get('annualized_return', 0)*100:.2f}%")
        print(f"‚öñÔ∏è  ÏÉ§ÌîÑ ÎπÑÏú®: {backtest_data.get('sharpe_ratio', 0):.4f}")
        print(f"üìâ ÏµúÎåÄ ÎÇôÌè≠: {backtest_data.get('max_drawdown', 0)*100:.2f}%")
        print(f"üéØ ÏäπÎ•†: {backtest_data.get('win_rate', 0)*100:.2f}%")
        print(f"üîÑ Ï¥ù Í±∞Îûò Ïàò: {backtest_data.get('total_trades', 0):,}")
        print(f"‚ö° Profit Factor: {backtest_data.get('profit_factor', 0):.4f}")
        
        # Parameters Ï†ïÎ≥¥ Ï∂úÎ†•
        parameters = backtest_data.get('parameters', {})
        if isinstance(parameters, str):
            try:
                parameters = json.loads(parameters)
            except:
                parameters = {}
        
        print(f"üìÅ Î™®Îç∏ Í≤ΩÎ°ú: {parameters.get('model_path', 'N/A')}")
        print(f"üìä Îç∞Ïù¥ÌÑ∞ ÌÉÄÏûÖ: {parameters.get('data_type', 'N/A')}")
        print(f"üè∑Ô∏è  Î™®Îç∏ ÌÉÄÏûÖ: {parameters.get('model_type', 'N/A')}")
        
        # Î∞±ÌÖåÏä§ÌåÖ ÏÜåÏöî ÏãúÍ∞Ñ (ParametersÏóêÏÑú)
        duration_seconds = parameters.get('backtest_duration_seconds', 0)
        if duration_seconds > 0:
            hours = int(duration_seconds // 3600)
            minutes = int((duration_seconds % 3600) // 60)
            seconds = int(duration_seconds % 60)
            if hours > 0:
                duration_display = f"{hours}ÏãúÍ∞Ñ {minutes}Î∂Ñ {seconds}Ï¥à"
            elif minutes > 0:
                duration_display = f"{minutes}Î∂Ñ {seconds}Ï¥à"
            else:
                duration_display = f"{seconds}Ï¥à"
            print(f"‚è±Ô∏è  Ïã§Ìñâ ÏãúÍ∞Ñ: {duration_display}")
        
        print("=" * 50 + "\n")

    def __enter__(self):
        """Context manager ÏßÑÏûÖ"""
        self.connect()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        """Context manager Ï¢ÖÎ£å"""
        self.disconnect()