import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from tqdm import tqdm
import torch
import os
import json
from datetime import datetime
from typing import Dict, List, Tuple, Any, Optional, Union

from src.models.sac_agent import SACAgent
from src.environment.trading_env import TradingEnvironment
from src.utils.logger import Logger

from src.config.ea_teb_config import Config
from src.config.ea_teb_config import (
    DEVICE,
    TARGET_SYMBOLS,
    LOGGER,
    WINDOW_SIZE,
    INITIAL_BALANCE,
    TRANSACTION_FEE_PERCENT,
    # MySQL ì„¤ì • ì¶”ê°€
    MYSQL_HOST,
    MYSQL_DATABASE,
    MYSQL_USER,
    MYSQL_PASSWORD,
    MYSQL_PORT,
    SAVE_TO_DATABASE,
    SKIP_DB_ON_ERROR
)
from src.utils.utils import create_directory


class Backtester:
    """
    ë°±í…ŒìŠ¤íŒ… ëª¨ë“ˆ: í•™ìŠµëœ SAC ì—ì´ì „íŠ¸ë¥¼ ì‚¬ìš©í•˜ì—¬ ê³¼ê±° ë°ì´í„°ì—ì„œ ì„±ëŠ¥ì„ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤.
    """

    def __init__(self, agent, test_data, config, logger, initial_balance=INITIAL_BALANCE,
                 transaction_fee_percent=TRANSACTION_FEE_PERCENT, save_to_db=True, skip_db_on_error=True):
        """
        Backtester í´ë˜ìŠ¤ ì´ˆê¸°í™”

        Args:
            agent: í•™ìŠµëœ SAC ì—ì´ì „íŠ¸
            test_data: í…ŒìŠ¤íŠ¸í•  ê³¼ê±° ë°ì´í„°
            config: ì„¤ì • ê°ì²´
            logger: ë¡œê¹…ì„ ìœ„í•œ Logger ì¸ìŠ¤í„´ìŠ¤ (ì˜µì…˜)
            initial_balance: ì´ˆê¸° ìë³¸ê¸ˆ
            save_to_db: ë°ì´í„°ë² ì´ìŠ¤ ì €ì¥ ì—¬ë¶€
            skip_db_on_error: DB ì˜¤ë¥˜ ì‹œ ë¬´ì‹œ ì—¬ë¶€
        """
        self.agent = agent
        self.test_data = test_data
        self.config = config
        self.logger = logger
        self.initial_balance = initial_balance
        self.transaction_fee_percent = transaction_fee_percent
        self.save_to_db = save_to_db
        self.skip_db_on_error = skip_db_on_error
        
        
        # Remove reward_scaling parameter or check if TradingEnvironment accepts it
        self.env = TradingEnvironment(
            data=test_data,
            raw_data=test_data,
            window_size=getattr(config, 'window_size', 20),
            initial_balance=initial_balance,
            transaction_fee_percent=transaction_fee_percent
            # reward_scaling=getattr(config, 'reward_scaling', 1.0)
        )

    def run_backtest(self, verbose: bool = True) -> Dict[str, Any]:
        """
        ë°±í…ŒìŠ¤íŠ¸ ì‹¤í–‰

        Args:
            verbose: ì§„í–‰ ìƒí™©ì„ í‘œì‹œí• ì§€ ì—¬ë¶€

        Returns:
            ë°±í…ŒìŠ¤íŠ¸ ê²°ê³¼ë¥¼ ë‹´ì€ ë”•ì…”ë„ˆë¦¬
        """
        # í™˜ê²½ ì´ˆê¸°í™”
        state = self.env.reset()
        done = False
        total_reward = 0
        self.results = {
            "portfolio_values": [],
            "returns": [],
            "actions": [],
            "positions": [],
            "rewards": [],
            "timestamps": [],
            "trades": [],
            "metrics": {}
        }
        # ë°±í…ŒìŠ¤íŠ¸ ì§„í–‰ ìƒí™© í‘œì‹œ ì„¤ì •
        iterator = tqdm(range(len(self.test_data) - self.config.window_size)) if verbose else range(
            len(self.test_data) - self.config.window_size)

        # ì—í”¼ì†Œë“œ ì§„í–‰
		# ë¦¬ìŠ¤í¬ ëª¨ë‹ˆí„°ë§ ì´ˆê¸°í™” 
        episode_max_portfolio = self.initial_balance
        episode_start_portfolio = self.initial_balance
        for _ in iterator:
            if done:
                break

            # ì—ì´ì „íŠ¸ë¡œë¶€í„° í–‰ë™ ì„ íƒ
            action = self.agent.select_action(state, evaluate=True)

            # í™˜ê²½ì—ì„œ í•œ ìŠ¤í… ì§„í–‰
            next_state, reward, done, info = self.env.step(action)
            if verbose:
                print(f"[Step {info['step']}]")
                for k, v in info.items():
                    print(f"  {k}: {v}")
            # ê²°ê³¼ ì €ì¥
            self.results["portfolio_values"].append(info["portfolio_value"])
			
            # ë¦¬ìŠ¤í¬ ì •ë³´ ìˆ˜ì§‘ (ìŠ¤í…ë³„)
            current_portfolio = info["portfolio_value"]
            episode_max_portfolio = max(episode_max_portfolio, current_portfolio)
            
            # ë‚™í­ ê³„ì‚°
            current_drawdown = (current_portfolio - episode_max_portfolio) / episode_max_portfolio * 100
            if current_drawdown < -5:  # 5% ì´ìƒ ë‚™í­
                self.risk_stats['max_drawdowns'].append(abs(current_drawdown))
            
            # ì¼ì¼ ì†ì‹¤ ê³„ì‚° (ì „ì¼ ëŒ€ë¹„)
            if len(self.results["portfolio_values"]) > 0:
                prev_portfolio = self.results["portfolio_values"][-1]
                daily_change = (current_portfolio - prev_portfolio) / prev_portfolio * 100
                if daily_change < -2:  # 2% ì´ìƒ ì¼ì¼ ì†ì‹¤
                    self.risk_stats['daily_losses'].append(abs(daily_change))
            self.results["returns"].append(info.get("return", 0))  # ê¸°ë³¸ê°’ 0ìœ¼ë¡œ ì•ˆì „í•˜ê²Œ ì ‘ê·¼
            self.results["actions"].append(action)
            self.results["positions"].append(info["position"])
            self.results["rewards"].append(reward)
            self.results["timestamps"].append(info["timestamps"])

            # ê±°ë˜ ê¸°ë¡ ì €ì¥
            if info["trade_executed"]:
                self.results["trades"].append({
                    "timestamp": info["timestamp"],
                    "action": action,
                    "price": info["current_price"],
                    "shares": info["trade_shares"],
                    "cost": info["trade_cost"],
                    "position": info["position"],
                    "portfolio_value": info["portfolio_value"]
                })

            # ìƒíƒœ ë° ë³´ìƒ ì—…ë°ì´íŠ¸
            state = next_state
            total_reward += reward

        # ë°ì´í„°í”„ë ˆì„ìœ¼ë¡œ ë³€í™˜
        self.results["portfolio_values"] = np.array(self.results["portfolio_values"])
        self.results["returns"] = np.array(self.results["returns"])
        self.results["actions"] = np.array(self.results["actions"])
        self.results["positions"] = np.array(self.results["positions"])
        self.results["rewards"] = np.array(self.results["rewards"])
		# ë¦¬ìŠ¤í¬ í†µê³„ ìµœì¢… ì²˜ë¦¬
        self.risk_stats['peak_portfolio_values'].append(episode_max_portfolio)
        self.risk_stats['total_episodes'] = 1
        
        # ë¦¬ìŠ¤í¬ í•œë„ ì´ˆê³¼ ì²´í¬
        max_episode_drawdown = max(self.risk_stats['max_drawdowns']) if self.risk_stats['max_drawdowns'] else 0
        if max_episode_drawdown > 15:  # 15% ë‚™í­ í•œë„ ì´ˆê³¼
            self.risk_stats['risk_exceeded_episodes'] = 1
        # ì„±ëŠ¥ ì§€í‘œ ê³„ì‚°
        self.calculate_metrics()

        # ë¡œê¹…
        if self.logger:
            self.logger.info(
                f"Backtest completed with final portfolio value: {self.results['portfolio_values'][-1]:.2f}")
            self.logger.info(f"Total reward: {total_reward:.2f}")
            self.logger.info(f"Performance metrics: {self.results['metrics']}")

        return self.results

    def calculate_metrics(self) -> Dict[str, float]:
        """
        ë°±í…ŒìŠ¤íŠ¸ ê²°ê³¼ì—ì„œ ì„±ëŠ¥ ì§€í‘œ ê³„ì‚°

        Returns:
            ì„±ëŠ¥ ì§€í‘œë¥¼ ë‹´ì€ ë”•ì…”ë„ˆë¦¬
        """
        # ì¼ë³„ ìˆ˜ìµë¥  ê³„ì‚°
        daily_returns = pd.Series(self.results["returns"])

        # ëˆ„ì  ìˆ˜ìµë¥ 
        cumulative_return = (self.results["portfolio_values"][-1] / self.initial_balance) - 1

        # ì—°ê°„í™”ëœ ìˆ˜ìµë¥  (252 íŠ¸ë ˆì´ë”© ë°ì´)
        n_days = len(daily_returns)
        annual_return = ((1 + cumulative_return) ** (252 / n_days)) - 1

        # ì¼ë³„ í‘œì¤€í¸ì°¨
        daily_std = daily_returns.std()

        # ì—°ê°„í™”ëœ ë³€ë™ì„±
        annual_volatility = daily_std * np.sqrt(252)

        # ìƒ¤í”„ ë¹„ìœ¨ (ë¬´ìœ„í—˜ ì´ììœ¨ 0% ê°€ì •)
        sharpe_ratio = annual_return / annual_volatility if annual_volatility != 0 else 0

        # ìµœëŒ€ ë‚™í­ (Maximum Drawdown)
        portfolio_values = pd.Series(self.results["portfolio_values"])
        cumulative_max = portfolio_values.cummax()
        drawdown = (portfolio_values - cumulative_max) / cumulative_max
        max_drawdown = drawdown.min()

        # ìŠ¹ë¥ 
        if len(self.results["trades"]) > 0:
            profitable_trades = sum(1 for trade in self.results["trades"] if
                                    (trade["action"] > 0 and self.results["returns"][
                                        self.results["timestamps"].index(trade["timestamp"])] > 0) or
                                    (trade["action"] < 0 and self.results["returns"][
                                        self.results["timestamps"].index(trade["timestamp"])] < 0))
            win_rate = profitable_trades / len(self.results["trades"])
        else:
            win_rate = 0

        # ì´ ê±°ë˜ íšŸìˆ˜
        total_trades = len(self.results["trades"])

        # ì§€í‘œ ì €ì¥
        metrics = {
            "cumulative_return": cumulative_return,
            "annual_return": annual_return,
            "annual_volatility": annual_volatility,
            "sharpe_ratio": sharpe_ratio,
            "max_drawdown": max_drawdown,
            "win_rate": win_rate,
            "total_trades": total_trades,
        }

        self.results["metrics"] = metrics
        return metrics

    def save_results(self, filepath: str, symbol: str = None, model_path: str = None,
                     data_type: str = 'test') -> None:
        """
        ë°±í…ŒìŠ¤íŠ¸ ê²°ê³¼ë¥¼ JSON íŒŒì¼ê³¼ ë°ì´í„°ë² ì´ìŠ¤ì— ì €ì¥

        Args:
            filepath: JSON ì €ì¥í•  íŒŒì¼ ê²½ë¡œ
            symbol: ì£¼ì‹ ì‹¬ë³¼ (DB ì €ì¥ìš©)
            model_path: ëª¨ë¸ ê²½ë¡œ (DB ì €ì¥ìš©)
            data_type: ë°ì´í„° íƒ€ì… (DB ì €ì¥ìš©)
        """
        # ê¸°ì¡´ JSON ì €ì¥ ì½”ë“œ
        save_data = {
            "initial_balance": self.initial_balance,
            "final_portfolio_value": float(self.results["portfolio_values"][-1]),
            "total_trades": len(self.results["trades"]),
            "metrics": self.results["metrics"],
            "trades": self.results["trades"],
            "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        }

        def convert_timestamps(obj):
            if isinstance(obj, dict):
                return {k: convert_timestamps(v) for k, v in obj.items()}
            elif isinstance(obj, list):
                return [convert_timestamps(i) for i in obj]
            elif isinstance(obj, pd.Timestamp):
                return obj.isoformat()
            else:
                return obj

        # ë””ë ‰í† ë¦¬ê°€ ì—†ìœ¼ë©´ ìƒì„±
        os.makedirs(os.path.dirname(filepath), exist_ok=True)

        json_data = convert_timestamps(save_data)

        # JSON íŒŒì¼ë¡œ ì €ì¥
        with open(filepath, 'w') as f:
            json.dump(json_data, f, indent=4)

        if self.logger:
            self.logger.info(f"Backtest results saved to {filepath}")

        # ===== ìƒˆë¡œ ì¶”ê°€ë˜ëŠ” DB ì €ì¥ ë¡œì§ =====
        if self.save_to_db and symbol and model_path:
            self._save_to_database(symbol, model_path, data_type)

    def _save_to_database(self, symbol: str, model_path: str, data_type: str = 'test') -> bool:
        """
        ë°±í…ŒìŠ¤íŠ¸ ê²°ê³¼ë¥¼ ë°ì´í„°ë² ì´ìŠ¤ì— ì €ì¥ (ë‚´ë¶€ ë©”ì„œë“œ)

        Args:
            symbol: ì£¼ì‹ ì‹¬ë³¼
            model_path: ëª¨ë¸ ê²½ë¡œ
            data_type: ë°ì´í„° íƒ€ì…

        Returns:
            bool: ì €ì¥ ì„±ê³µ ì—¬ë¶€
        """
        try:
            if self.logger:
                self.logger.info("ğŸ’¾ ë°ì´í„°ë² ì´ìŠ¤ ì €ì¥ ì‹œì‘...")

            # BacktestDatabaseManager import (ì§€ì—° importë¡œ ìˆœí™˜ import ë°©ì§€)
            from src.backtest.backtest_database_manager import BacktestDatabaseManager

            # ë°ì´í„°ë² ì´ìŠ¤ ë§¤ë‹ˆì € ìƒì„± ë° ì €ì¥
            with BacktestDatabaseManager(
                host=MYSQL_HOST,
                database=MYSQL_DATABASE,
                user=MYSQL_USER,
                password=MYSQL_PASSWORD,
                port=MYSQL_PORT
            ) as db_manager:

                # í…Œì´ë¸” ìƒì„± í™•ì¸
                if not db_manager.create_tables_if_not_exists():
                    raise Exception("í…Œì´ë¸” ìƒì„± ì‹¤íŒ¨")

                # ë°±í…ŒìŠ¤íŠ¸ ê²°ê³¼ë¥¼ DB í˜•ì‹ìœ¼ë¡œ ë³€í™˜
                # run_backtest.py í˜•ì‹ìœ¼ë¡œ ë³€í™˜
                converted_results = self._convert_to_run_backtest_format()

                db_data = db_manager.convert_backtest_results_to_db_format(
                    results=converted_results,
                    metrics=self.results["metrics"],
                    symbol=symbol,
                    model_path=model_path,
                    data_type=data_type
                )

                # ë°ì´í„°ë² ì´ìŠ¤ì— ì €ì¥
                backtest_id = db_manager.insert_backtest_result(
                    backtest_data=db_data,
                    trade_details=converted_results
                )

                if backtest_id:
                    if self.logger:
                        self.logger.info(f"âœ… ë°ì´í„°ë² ì´ìŠ¤ ì €ì¥ ì™„ë£Œ! (ID: {backtest_id})")
                    return True
                else:
                    raise Exception("ë°ì´í„°ë² ì´ìŠ¤ ì €ì¥ ì‹¤íŒ¨")

        except Exception as e:
            error_msg = f"âŒ ë°ì´í„°ë² ì´ìŠ¤ ì €ì¥ ì¤‘ ì˜¤ë¥˜: {str(e)}"

            if self.skip_db_on_error:
                if self.logger:
                    self.logger.warning(error_msg)
                    self.logger.warning("âš ï¸  DB ì €ì¥ ì˜¤ë¥˜ ë¬´ì‹œí•˜ê³  ê³„ì† ì§„í–‰...")
                return False
            else:
                if self.logger:
                    self.logger.error(error_msg)
                raise e

    def _convert_to_run_backtest_format(self) -> Dict[str, Any]:
        """
        Backtester ê²°ê³¼ë¥¼ run_backtest.py í˜•ì‹ìœ¼ë¡œ ë³€í™˜

        Returns:
            Dict: run_backtest í˜•ì‹ì˜ ê²°ê³¼ ë”•ì…”ë„ˆë¦¬
        """
        return {
            'initial_portfolio_value': self.initial_balance,
            'final_portfolio_value': float(self.results["portfolio_values"][-1]),
            'total_return': ((self.results["portfolio_values"][-1] / self.initial_balance) - 1) * 100,
            'portfolio_values': self.results["portfolio_values"].tolist() if hasattr(
                self.results["portfolio_values"], 'tolist') else list(self.results["portfolio_values"]),
            'prices': [trade.get('price', 0) for trade in self.results["trades"]],  # ê±°ë˜ ê°€ê²© ì¶”ì¶œ
            'positions': self.results["positions"].tolist() if hasattr(self.results["positions"],
                                                                         'tolist') else list(
                self.results["positions"]),
            'balances': [],  # Backtesterì—ì„œëŠ” ë³„ë„ ì¶”ì í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ ë¹ˆ ë¦¬ìŠ¤íŠ¸
            'shares': [],  # Backtesterì—ì„œëŠ” ë³„ë„ ì¶”ì í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ ë¹ˆ ë¦¬ìŠ¤íŠ¸
            'rewards': self.results["rewards"].tolist() if hasattr(self.results["rewards"],
                                                                     'tolist') else list(self.results["rewards"]),
            'actions': self.results["actions"].tolist() if hasattr(self.results["actions"],
                                                                     'tolist') else list(self.results["actions"])
        }

    def plot_portfolio_performance(self, save_path: Optional[str] = None) -> None:
        """
        í¬íŠ¸í´ë¦¬ì˜¤ ì„±ëŠ¥ ì‹œê°í™”

        Args:
            save_path: ê·¸ë˜í”„ë¥¼ ì €ì¥í•  íŒŒì¼ ê²½ë¡œ (ì˜µì…˜)
        """
        plt.figure(figsize=(14, 7))

        # ìŠ¤íƒ€ì¼ ì„¤ì •
        sns.set_style("whitegrid")

        # í¬íŠ¸í´ë¦¬ì˜¤ ê°€ì¹˜ í”Œë¡¯
        plt.plot(self.results["portfolio_values"], label="Portfolio Value", color="royalblue", linewidth=2)

        # ë§¤ìˆ˜/ë§¤ë„ ì§€ì  í‘œì‹œ
        for trade in self.results["trades"]:
            idx = self.results["timestamps"].index(trade["timestamp"])

            if trade["action"] > 0:  # ë§¤ìˆ˜
                plt.scatter(idx, self.results["portfolio_values"][idx], color="green", marker="^", s=100)
            elif trade["action"] < 0:  # ë§¤ë„
                plt.scatter(idx, self.results["portfolio_values"][idx], color="red", marker="v", s=100)

        # ì„±ëŠ¥ ì§€í‘œ í…ìŠ¤íŠ¸
        metrics_text = f"""
        Cumulative Return: {self.results['metrics']['cumulative_return']:.2%}
        Annual Return: {self.results['metrics']['annual_return']:.2%}
        Sharpe Ratio: {self.results['metrics']['sharpe_ratio']:.2f}
        Max Drawdown: {self.results['metrics']['max_drawdown']:.2%}
        Win Rate: {self.results['metrics']['win_rate']:.2%}
        Total Trades: {self.results['metrics']['total_trades']}
        """

        plt.text(0.02, 0.97, metrics_text, transform=plt.gca().transAxes,
                 verticalalignment='top', bbox=dict(boxstyle='round', alpha=0.3))

        # ê·¸ë˜í”„ ë ˆì´ë¸” ë° ì œëª©
        plt.title("Portfolio Performance during Backtest", fontsize=16)
        plt.xlabel("Trading Days", fontsize=12)
        plt.ylabel("Portfolio Value ($)", fontsize=12)
        plt.legend()
        plt.tight_layout()

        # ì €ì¥ ë˜ëŠ” í‘œì‹œ
        if save_path:
            plt.savefig(save_path, dpi=300, bbox_inches="tight")
            if self.logger:
                self.logger.info(f"Portfolio performance plot saved to {save_path}")
        else:
            plt.show()

    def plot_drawdown(self, save_path: Optional[str] = None) -> None:
        """
        ë‚™í­(Drawdown) ì‹œê°í™”

        Args:
            save_path: ê·¸ë˜í”„ë¥¼ ì €ì¥í•  íŒŒì¼ ê²½ë¡œ (ì˜µì…˜)
        """
        plt.figure(figsize=(14, 7))

        # ìŠ¤íƒ€ì¼ ì„¤ì •
        sns.set_style("whitegrid")

        # í¬íŠ¸í´ë¦¬ì˜¤ ê°€ì¹˜
        portfolio_values = pd.Series(self.results["portfolio_values"])

        # ëˆ„ì  ìµœëŒ€ê°’
        cumulative_max = portfolio_values.cummax()

        # ë‚™í­ ê³„ì‚°
        drawdown = (portfolio_values - cumulative_max) / cumulative_max

        # ë‚™í­ í”Œë¡¯
        plt.fill_between(range(len(drawdown)), 0, drawdown, color='crimson', alpha=0.3, label='Drawdown')
        plt.plot(drawdown, color='crimson', linestyle='-', linewidth=1)

        # ìµœëŒ€ ë‚™í­ í‘œì‹œ
        max_dd = drawdown.min()
        max_dd_idx = drawdown.argmin()
        plt.scatter(max_dd_idx, max_dd, color='darkred', marker='o', s=100, label=f'Max Drawdown: {max_dd:.2%}')

        # ê·¸ë˜í”„ ë ˆì´ë¸” ë° ì œëª©
        plt.title("Portfolio Drawdown", fontsize=16)
        plt.xlabel("Trading Days", fontsize=12)
        plt.ylabel("Drawdown", fontsize=12)
        plt.legend()
        plt.tight_layout()

        # ì €ì¥ ë˜ëŠ” í‘œì‹œ
        if save_path:
            plt.savefig(save_path, dpi=300, bbox_inches="tight")
            if self.logger:
                self.logger.info(f"Drawdown plot saved to {save_path}")
        else:
            plt.show()

    def plot_returns_distribution(self, save_path: Optional[str] = None) -> None:
        """
        ìˆ˜ìµë¥  ë¶„í¬ ì‹œê°í™”

        Args:
            save_path: ê·¸ë˜í”„ë¥¼ ì €ì¥í•  íŒŒì¼ ê²½ë¡œ (ì˜µì…˜)
        """
        plt.figure(figsize=(14, 7))

        # ìŠ¤íƒ€ì¼ ì„¤ì •
        sns.set_style("whitegrid")

        # ì¼ë³„ ìˆ˜ìµë¥ 
        daily_returns = pd.Series(self.results["returns"])

        # ìˆ˜ìµë¥  ë¶„í¬ í”Œë¡¯
        sns.histplot(daily_returns, kde=True, color="royalblue")

        # 0ì„  í‘œì‹œ
        plt.axvline(x=0, color='r', linestyle='--', alpha=0.7)

        # í‰ê·  ìˆ˜ìµë¥  í‘œì‹œ
        mean_return = daily_returns.mean()
        plt.axvline(x=mean_return, color='green', linestyle='-', alpha=0.7)

        # í†µê³„ ì •ë³´
        stats_text = f"""
        Mean Return: {mean_return:.4%}
        Std Deviation: {daily_returns.std():.4%}
        Min Return: {daily_returns.min():.4%}
        Max Return: {daily_returns.max():.4%}
        Skewness: {daily_returns.skew():.4f}
        Kurtosis: {daily_returns.kurtosis():.4f}
        """

        plt.text(0.02, 0.97, stats_text, transform=plt.gca().transAxes,
                 verticalalignment='top', bbox=dict(boxstyle='round', alpha=0.3))

        # ê·¸ë˜í”„ ë ˆì´ë¸” ë° ì œëª©
        plt.title("Distribution of Daily Returns", fontsize=16)
        plt.xlabel("Daily Return", fontsize=12)
        plt.ylabel("Frequency", fontsize=12)
        plt.tight_layout()

        # ì €ì¥ ë˜ëŠ” í‘œì‹œ
        if save_path:
            plt.savefig(save_path, dpi=300, bbox_inches="tight")
            if self.logger:
                self.logger.info(f"Returns distribution plot saved to {save_path}")
        else:
            plt.show()

    def visualize_results(self, save_dir: Optional[str] = None) -> None:
        """
        ë°±í…ŒìŠ¤íŠ¸ ê²°ê³¼ë¥¼ ì‹œê°í™”í•˜ê³  ì €ì¥

        Args:
            save_dir: ì‹œê°í™” ê²°ê³¼ë¥¼ ì €ì¥í•  ë””ë ‰í† ë¦¬ ê²½ë¡œ (ì˜µì…˜)
        """
        # ì €ì¥ ë””ë ‰í† ë¦¬ ì„¤ì •
        if save_dir:
            os.makedirs(save_dir, exist_ok=True)
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")

            # í¬íŠ¸í´ë¦¬ì˜¤ ì„±ëŠ¥ ì°¨íŠ¸
            portfolio_path = os.path.join(save_dir, f"portfolio_performance_{timestamp}.png")
            self.plot_portfolio_performance(portfolio_path)

            # ë‚™í­ ì°¨íŠ¸
            drawdown_path = os.path.join(save_dir, f"drawdown_{timestamp}.png")
            self.plot_drawdown(drawdown_path)

            # ìˆ˜ìµë¥  ë¶„í¬ ì°¨íŠ¸
            returns_path = os.path.join(save_dir, f"returns_distribution_{timestamp}.png")
            self.plot_returns_distribution(returns_path)

            # ê²°ê³¼ ë°ì´í„° ì €ì¥
            results_path = os.path.join(save_dir, f"backtest_results_{timestamp}.json")
            self.save_results(results_path)
        else:
            # ì‹œê°í™”ë§Œ ìˆ˜í–‰
            self.plot_portfolio_performance()
            self.plot_drawdown()
            self.plot_returns_distribution()