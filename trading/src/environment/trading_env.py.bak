"""
ê°•í™”í•™ìŠµì„ ìœ„í•œ íŠ¸ë ˆì´ë”© í™˜ê²½ ëª¨ë“ˆ (ì •ë¦¬ëœ ë²„ì „)
"""
import sys
import os

project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '../..'))
sys.path.append(project_root)

import numpy as np
import pandas as pd
from typing import Dict, List, Tuple, Union, Optional, Any
import gym
from gym import spaces
from src.data_collection.data_collector import DataCollector
from decimal import Decimal, ROUND_DOWN, getcontext

# ì €ì¥ ê²½ë¡œ í´ë” ìƒì„±
save_dir = './results'
os.makedirs(save_dir, exist_ok=True)

from src.config.ea_teb_config import (
    INITIAL_BALANCE,
    MAX_TRADING_UNITS,
    TRANSACTION_FEE_PERCENT,
    WINDOW_SIZE,
    LOGGER,
	MAX_DRAWDOWN, 
	MAX_DAILY_LOSS, 
	EMERGENCY_STOP_LOSS
)

class TradingEnvironment:
    """
    ê°•í™”í•™ìŠµì„ ìœ„í•œ íŠ¸ë ˆì´ë”© í™˜ê²½ í´ë˜ìŠ¤ (ì •ë¦¬ëœ ë²„ì „)
    """
    
    def __init__(
        self,
        data: pd.DataFrame,
        raw_data: pd.DataFrame = None,
        window_size: int = WINDOW_SIZE,
        initial_balance: float = INITIAL_BALANCE,
        max_trading_units: int = MAX_TRADING_UNITS,
        transaction_fee_percent: float = TRANSACTION_FEE_PERCENT,
        symbol: str = None,
        train_data: bool = True,
        reward_mode: str = 'combined',
        detailed_logging: bool = True,
    ):
        """
        TradingEnvironment í´ë˜ìŠ¤ ì´ˆê¸°í™”
        """
        # ğŸ“Š ê¸°ë³¸ ë°ì´í„° ì„¤ì •
        self.data = data
        if raw_data is not None:
            self.raw_data = raw_data
        else:
            LOGGER.warning("âš ï¸ raw_dataê°€ ì œê³µë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ì •ê·œí™”ëœ ë°ì´í„°ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.")
            self.raw_data = data
        
        print(f'ğŸ“ˆ ì •ê·œí™”ëœ ë°ì´í„° í˜•íƒœ: {data.shape}')
        print(f'ğŸ“Š ì›ë³¸ ë°ì´í„° í˜•íƒœ: {self.raw_data.shape}')
        
        # â° íƒ€ì„ìŠ¤íƒ¬í”„ ì´ˆê¸°í™”
        if hasattr(self.raw_data.index, 'values'):
            self.timestamps = self.raw_data.index.values
        else:
            self.timestamps = np.array([None] * len(self.raw_data))

        # ğŸ¯ í™˜ê²½ ì„¤ì • íŒŒë¼ë¯¸í„°
        self.window_size = window_size
        self.initial_balance = initial_balance
        self.max_trading_units = max_trading_units
        self.transaction_fee_percent = transaction_fee_percent
        self.symbol = symbol if symbol else "UNKNOWN"
        self.train_data = train_data
        self.reward_mode = reward_mode
        self.detailed_logging = detailed_logging
        
        # ğŸ“ ë°ì´í„° ê´€ë ¨ ë³€ìˆ˜
        self.feature_dim = data.shape[1]
        self.data_length = len(data)
        
        # ğŸ’° í™˜ê²½ ìƒíƒœ ë³€ìˆ˜ ì´ˆê¸°í™”
        self._init_state_variables()
        
        # ğŸ® í–‰ë™ ê³µê°„: [-1.0, 1.0] ë²”ìœ„ì˜ ì—°ì†ì ì¸ ê°’
        self.action_space = spaces.Box(low=-1.0, high=1.0, shape=(1,), dtype=np.float32)
        
        # ğŸ‘€ ê´€ì¸¡ ê³µê°„: ê°€ê²© ë°ì´í„° + í¬íŠ¸í´ë¦¬ì˜¤ ìƒíƒœ
        self.observation_space = spaces.Dict({
            'market_data': spaces.Box(
                low=-np.inf, high=np.inf, shape=(self.window_size, self.feature_dim), dtype=np.float32
            ),
            'portfolio_state': spaces.Box(
                low=0, high=np.inf, shape=(2,), dtype=np.float32
            )
        })
        
        # ğŸ” ì›ë³¸ ë°ì´í„° ê²€ì¦
        if 'close' not in self.raw_data.columns:
            LOGGER.warning("âš ï¸ raw_dataì— 'close' ì»¬ëŸ¼ì´ ì—†ìŠµë‹ˆë‹¤. ë§ˆì§€ë§‰ ì»¬ëŸ¼ì„ ì¢…ê°€ë¡œ ì‚¬ìš©í•©ë‹ˆë‹¤.")
        
        # âœ… ìœ íš¨ì„± ê²€ì‚¬
        valid_modes = ['combined', 'trade_only', 'market_only', 'separated']
        if reward_mode not in valid_modes:
            raise ValueError(f"reward_modeëŠ” {valid_modes} ì¤‘ í•˜ë‚˜ì—¬ì•¼ í•©ë‹ˆë‹¤")
        
        LOGGER.info(f"âœ… {self.symbol} íŠ¸ë ˆì´ë”© í™˜ê²½ ì´ˆê¸°í™” ì™„ë£Œ: ë°ì´í„° ê¸¸ì´ {self.data_length}")
        LOGGER.info(f"ğŸ¯ ë³´ìƒ ëª¨ë“œ: {reward_mode}, ğŸ“ ìƒì„¸ ë¡œê¹…: {detailed_logging}")

    def _init_state_variables(self):
        """ğŸ’° í™˜ê²½ ìƒíƒœ ë³€ìˆ˜ ì´ˆê¸°í™”"""
        self.current_step = 0
        self.balance = self.initial_balance
        self.shares_held = 0
        self.cost_basis = 0
        self.total_shares_purchased = 0
        self.total_shares_sold = 0
        self.total_sales_value = 0
        self.total_commission = 0
        self.position = "í™€ë“œ"
        self.trade_executed = False 
        self.previous_shares_held = 0
        self.invalid_sell_penalty = False
        
        # ğŸ“ˆ ì—í”¼ì†Œë“œ íˆìŠ¤í† ë¦¬
        self.states_history = []
        self.actions_history = []
        self.rewards_history = []
        self.portfolio_values_history = []
        self.trade_effects_history = []
        self.market_effects_history = []
        self.combined_effects_history = []
    
    def reset(self) -> Dict[str, np.ndarray]:
        """
        ğŸ”„ í™˜ê²½ ì´ˆê¸°í™”
        """
        print(f"\nğŸ”„ í™˜ê²½ ë¦¬ì…‹ ì‹œì‘ - {self.symbol}")
        self._init_state_variables()
        print(f"ğŸ’° ì´ˆê¸° ì”ê³ : ${self.initial_balance:.2f}")
        return self._get_observation()

    def _get_current_price(self) -> float:
        """
        ğŸ’µ í˜„ì¬ ì£¼ê°€ ë°˜í™˜ (ë””ë²„ê¹… ìµœì í™”)
        """
        # ğŸ” ì¸ë±ìŠ¤ ìœ íš¨ì„± ê²€ì‚¬
        if self.current_step >= len(self.raw_data):
            last_valid_index = len(self.raw_data) - 1
            LOGGER.warning(f"âš ï¸ ì¸ë±ìŠ¤ ë²”ìœ„ ì´ˆê³¼: {self.current_step} >= {len(self.raw_data)}, ë§ˆì§€ë§‰ ìœ íš¨í•œ ê°€ê²© ì‚¬ìš©")
            
            if 'close' in self.raw_data.columns:
                price = float(self.raw_data.iloc[last_valid_index]['close'])
            else:
                price = float(self.raw_data.iloc[last_valid_index][-1])
        else:
            # ğŸ“Š ì •ìƒì ì¸ ê²½ìš°
            if 'close' in self.raw_data.columns:
                price = float(self.raw_data.iloc[self.current_step]['close'])
            else:
                price = float(self.raw_data.iloc[self.current_step][-1])
                
            # ğŸ” ë””ë²„ê¹…: ìŠ¤í…ë‹¹ í•œ ë²ˆë§Œ ì¶œë ¥ (ì²« ë²ˆì§¸ í˜¸ì¶œì—ì„œë§Œ)
            debug_key = f"price_debug_{self.current_step}"
            if self.current_step >= 70 and not hasattr(self, debug_key):
                setattr(self, debug_key, True)  # ì´ ìŠ¤í…ì—ì„œ ì´ë¯¸ ë””ë²„ê¹…í–ˆë‹¤ê³  í‘œì‹œ
                
                current_timestamp = self.raw_data.index[self.current_step]
                print(f"ğŸ” ê°€ê²© ë””ë²„ê¹… (Step {self.current_step}):")
                print(f"  â° íƒ€ì„ìŠ¤íƒ¬í”„: {current_timestamp}")
                print(f"  ğŸ’µ ê°€ê²©: ${price:.2f}")
                
                # ì´ì „ ìŠ¤í…ê³¼ ë¹„êµ
                if self.current_step > 0 and self.current_step - 1 < len(self.raw_data):
                    prev_timestamp = self.raw_data.index[self.current_step - 1]
                    if 'close' in self.raw_data.columns:
                        prev_price = float(self.raw_data.iloc[self.current_step - 1]['close'])
                    else:
                        prev_price = float(self.raw_data.iloc[self.current_step - 1][-1])
                    
                    price_change = price - prev_price
                    print(f"  ğŸ“Š ì´ì „ ìŠ¤í…: {self.current_step - 1} (${prev_price:.2f})")
                    print(f"  ğŸ“ˆ ê°€ê²© ë³€í™”: ${price_change:.2f}")
                    
                    if abs(price_change) < 0.01:
                        print(f"  âš ï¸ ê°€ê²©ì´ ê±°ì˜ ë™ì¼!")
                    elif price_change > 0:
                        print(f"  ğŸ“ˆ ê°€ê²© ìƒìŠ¹!")
                    else:
                        print(f"  ğŸ“‰ ê°€ê²© í•˜ë½!")
                print()
        
        # ğŸš¨ ê°€ê²©ì´ 0 ì´í•˜ì¸ ê²½ìš° ì²˜ë¦¬
        if price <= 0:
            LOGGER.warning(f"âš ï¸ í˜„ì¬ ê°€ê²©ì´ 0 ì´í•˜ì…ë‹ˆë‹¤: {price}, ìµœì†Œê°’ìœ¼ë¡œ ì¡°ì •")
            price = 0.01
            
        return price

    def _execute_trade_action(self, action: float) -> None:
        """
        ğŸ”„ ê±°ë˜ í–‰ë™ ì‹¤í–‰ (ë””ë²„ê¹… ê°•í™”)
        """
        current_price = self._get_current_price()
        
        # ğŸš¨ í˜„ì¬ ê°€ê²© ìœ íš¨ì„± í™•ì¸
        if current_price <= 0:
            LOGGER.warning(f"âš ï¸ í˜„ì¬ ê°€ê²©ì´ 0 ì´í•˜ì…ë‹ˆë‹¤: {current_price}")
            return
        
        # ğŸ¯ í–‰ë™ ê°’ ì²˜ë¦¬
        action_value = action[0] if isinstance(action, np.ndarray) else action
        
        # ğŸ“Š ê±°ë˜ ì „ ìƒíƒœ ì €ì¥ (ìƒì„¸ ë””ë²„ê¹…ìš©)
        old_balance = self.balance
        old_shares = self.shares_held
        old_portfolio_value = old_balance + old_shares * current_price
        
        print(f"\nğŸ’¼ ê±°ë˜ ì‹¤í–‰ ì‹œì‘ - Step {self.current_step}")
        print(f"ğŸ“Š í–‰ë™ ê°’: {action_value:.4f}")
        print(f"ğŸ’µ í˜„ì¬ ê°€ê²©: ${current_price:.2f}")
        print(f"ğŸ’° ê±°ë˜ ì „ ì”ê³ : ${self.balance:.2f}")
        print(f"ğŸ“ˆ ê±°ë˜ ì „ ë³´ìœ ëŸ‰: {self.shares_held:.4f}")
        print(f"ğŸ’ ê±°ë˜ ì „ í¬íŠ¸í´ë¦¬ì˜¤: ${old_portfolio_value:.2f}")
        
        # ğŸ® ê¸°ë³¸ ìƒíƒœ ì„¤ì •
        self.trade_executed = False
        self.position = "í™€ë“œ"
        self.invalid_sell_penalty = False
        
        # ğŸ’ª ìµœì†Œ í–‰ë™ ì„ê³„ê°’ ì²˜ë¦¬
        min_action_threshold = 0.1
        if 0 < abs(action_value) < min_action_threshold:
            action_value = min_action_threshold * (1 if action_value > 0 else -1)
            print(f"ğŸ”§ í–‰ë™ ê°’ ì¦í­: {action_value:.4f}")
        
        getcontext().prec = 10
        
        if action_value > 0:  # ğŸ’° ë§¤ìˆ˜
            self._execute_buy(action_value, current_price)
            
        elif action_value < 0:  # ğŸ’¸ ë§¤ë„
            self._execute_sell(action_value, current_price)
        
        else:  # ğŸ¤š í™€ë“œ
            print(f"ğŸ¤š í™€ë“œ (í–‰ë™ ê°’ì´ 0)")
        
        # ğŸ“Š ê±°ë˜ í›„ ìƒíƒœ ì¶œë ¥ (ìƒì„¸ ë¶„ì„)
        new_portfolio_value = self.balance + self.shares_held * current_price
        balance_change = self.balance - old_balance
        shares_change = self.shares_held - old_shares
        portfolio_change = new_portfolio_value - old_portfolio_value
        
        print(f"\nğŸ“Š ê±°ë˜ ê²°ê³¼ ë¶„ì„:")
        print(f"ğŸ’° ì”ê³  ë³€í™”: ${old_balance:.2f} â†’ ${self.balance:.2f} (ë³€í™”: ${balance_change:.2f})")
        print(f"ğŸ“ˆ ë³´ìœ ëŸ‰ ë³€í™”: {old_shares:.4f} â†’ {self.shares_held:.4f} (ë³€í™”: {shares_change:.4f})")
        print(f"ğŸ’ í¬íŠ¸í´ë¦¬ì˜¤ ë³€í™”: ${old_portfolio_value:.2f} â†’ ${new_portfolio_value:.2f} (ë³€í™”: ${portfolio_change:.2f})")
        
        # ğŸ” ê±°ë˜ ìœ í˜•ë³„ ì˜ˆìƒ ë³€í™” ê³„ì‚°
        if self.trade_executed:
            if action_value > 0:  # ë§¤ìˆ˜
                expected_cost = shares_change * current_price * (1 + self.transaction_fee_percent)
                print(f"ğŸ’° ë§¤ìˆ˜ - ì˜ˆìƒ ë¹„ìš©: ${expected_cost:.2f}, ì‹¤ì œ ì”ê³  ê°ì†Œ: ${-balance_change:.2f}")
                print(f"ğŸ“ˆ ë§¤ìˆ˜ - ì˜ˆìƒ ìˆ˜ìˆ˜ë£Œ: ${expected_cost - (shares_change * current_price):.2f}")
            else:  # ë§¤ë„
                expected_income = abs(shares_change) * current_price * (1 - self.transaction_fee_percent)
                print(f"ğŸ’¸ ë§¤ë„ - ì˜ˆìƒ ìˆ˜ìµ: ${expected_income:.2f}, ì‹¤ì œ ì”ê³  ì¦ê°€: ${balance_change:.2f}")
                print(f"ğŸ“ˆ ë§¤ë„ - ì˜ˆìƒ ìˆ˜ìˆ˜ë£Œ: ${(abs(shares_change) * current_price) - expected_income:.2f}")
        
        # ğŸš¨ í¬íŠ¸í´ë¦¬ì˜¤ ë³€í™”ê°€ ì˜ˆìƒê³¼ ë‹¤ë¥¸ ê²½ìš° ê²½ê³ 
        if self.trade_executed and abs(portfolio_change) > 1.0:  # 1ë‹¬ëŸ¬ ì´ìƒ ì°¨ì´
            print(f"ğŸš¨ ì˜ˆìƒì¹˜ ëª»í•œ í¬íŠ¸í´ë¦¬ì˜¤ ë³€í™”: ${portfolio_change:.2f}")
            print(f"   ìˆ˜ìˆ˜ë£Œë§Œìœ¼ë¡œëŠ” ${abs(portfolio_change):.2f} ì°¨ì´ë¥¼ ì„¤ëª…í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤!")
        elif self.trade_executed:
            print(f"âœ… í¬íŠ¸í´ë¦¬ì˜¤ ë³€í™”ê°€ ìˆ˜ìˆ˜ë£Œ ë²”ìœ„ ë‚´: ${portfolio_change:.2f}")
        
        print(f"{'='*60}")

    def _execute_buy(self, action_value: float, current_price: float) -> None:
        """ğŸ’° ë§¤ìˆ˜ ì‹¤í–‰"""
        # ğŸ§® ë§¤ìˆ˜í•  ìˆ˜ ìˆëŠ” ìµœëŒ€ ì£¼ì‹ ìˆ˜ ê³„ì‚°
        max_affordable = self.balance / (current_price * (1 + self.transaction_fee_percent))
        shares_to_buy = min(max_affordable, self.max_trading_units * action_value)
        
        print(f"ğŸ’° ë§¤ìˆ˜ ì‹œë„:")
        print(f"  ğŸ“Š êµ¬ë§¤ ê°€ëŠ¥ ìµœëŒ€ëŸ‰: {max_affordable:.4f}")
        print(f"  ğŸ¯ ì›í•˜ëŠ” ë§¤ìˆ˜ëŸ‰: {self.max_trading_units * action_value:.4f}")
        print(f"  âœ… ì‹¤ì œ ë§¤ìˆ˜ëŸ‰: {shares_to_buy:.4f}")
        
        if shares_to_buy > 0:
            # ğŸ”§ ì†Œìˆ˜ì  ì²˜ë¦¬
            shares_to_buy = float(Decimal(str(shares_to_buy)).quantize(Decimal('0.0001'), rounding=ROUND_DOWN))
            
            # ğŸ’° ë¹„ìš© ê³„ì‚°
            buy_cost = shares_to_buy * current_price
            commission = buy_cost * self.transaction_fee_percent
            total_cost = buy_cost + commission
            
            print(f"  ğŸ’µ ë§¤ìˆ˜ ë¹„ìš©: ${buy_cost:.2f}")
            print(f"  ğŸ’¸ ìˆ˜ìˆ˜ë£Œ: ${commission:.2f}")
            print(f"  ğŸ’ ì´ ë¹„ìš©: ${total_cost:.2f}")
            
            if self.balance >= total_cost:
                # âœ… ë§¤ìˆ˜ ì‹¤í–‰
                self.balance -= total_cost
                self.shares_held += shares_to_buy
                self.total_shares_purchased += shares_to_buy
                self.total_commission += commission
                
                # ğŸ“Š ê±°ë˜ ìƒíƒœ ì—…ë°ì´íŠ¸
                self.trade_executed = True
                self.position = "ë§¤ìˆ˜"
                
                # ğŸ“ˆ í‰ê·  ë§¤ìˆ˜ ë‹¨ê°€ ì—…ë°ì´íŠ¸
                if self.shares_held > 0:
                    self.cost_basis = ((self.cost_basis * (self.shares_held - shares_to_buy)) + buy_cost) / self.shares_held
                
                print(f"  âœ… ë§¤ìˆ˜ ì„±ê³µ: {shares_to_buy}ì£¼ @ ${current_price:.2f}")
            else:
                print(f"  âŒ ì”ê³  ë¶€ì¡±: í•„ìš” ${total_cost:.2f}, ë³´ìœ  ${self.balance:.2f}")

    def _execute_sell(self, action_value: float, current_price: float) -> None:
        """ğŸ’¸ ë§¤ë„ ì‹¤í–‰ (ìƒì„¸ ê³„ì‚° ê²€ì¦)"""
        shares_to_sell = min(self.shares_held, self.max_trading_units * abs(action_value))
        
        print(f"ğŸ’¸ ë§¤ë„ ì‹œë„:")
        print(f"  ğŸ“Š í˜„ì¬ ë³´ìœ ëŸ‰: {self.shares_held:.4f}")
        print(f"  ğŸ¯ ì›í•˜ëŠ” ë§¤ë„ëŸ‰: {self.max_trading_units * abs(action_value):.4f}")
        print(f"  âœ… ì‹¤ì œ ë§¤ë„ëŸ‰: {shares_to_sell:.4f}")
        print(f"  ğŸ’µ ë§¤ë„ ê°€ê²©: ${current_price:.2f}")
        
        if shares_to_sell > 0:
            # ğŸ”§ ì†Œìˆ˜ì  ì²˜ë¦¬
            shares_to_sell = float(Decimal(str(shares_to_sell)).quantize(Decimal('0.0001'), rounding=ROUND_DOWN))
            
            if shares_to_sell <= 0:
                print(f"  âŒ ì†Œìˆ˜ì  ì²˜ë¦¬ í›„ ë§¤ë„ëŸ‰ì´ 0ì´ ë˜ì—ˆìŠµë‹ˆë‹¤!")
                return
            
            # ğŸ’° ìˆ˜ìµ ê³„ì‚° - ìƒì„¸ ë‹¨ê³„ë³„ ê³„ì‚°
            gross_sell_value = shares_to_sell * current_price  # ì´ ë§¤ë„ ê¸ˆì•¡
            commission = gross_sell_value * self.transaction_fee_percent  # ìˆ˜ìˆ˜ë£Œ
            net_value = gross_sell_value - commission  # ìˆœ ìˆ˜ìµ
            
            print(f"  ğŸ“Š ìƒì„¸ ë§¤ë„ ê³„ì‚°:")
            print(f"    ğŸ’µ ì´ ë§¤ë„ ê¸ˆì•¡: {shares_to_sell:.4f} Ã— ${current_price:.2f} = ${gross_sell_value:.2f}")
            print(f"    ğŸ’¸ ìˆ˜ìˆ˜ë£Œìœ¨: {self.transaction_fee_percent:.4f}")
            print(f"    ğŸ’¸ ìˆ˜ìˆ˜ë£Œ ê¸ˆì•¡: ${gross_sell_value:.2f} Ã— {self.transaction_fee_percent:.4f} = ${commission:.2f}")
            print(f"    ğŸ’ ìˆœ ìˆ˜ìµ: ${gross_sell_value:.2f} - ${commission:.2f} = ${net_value:.2f}")
            
            # ğŸ“Š ê±°ë˜ ì „ ìƒíƒœ ì €ì¥
            old_balance = self.balance
            old_shares = self.shares_held
            
            # âœ… ë§¤ë„ ì‹¤í–‰
            self.balance += net_value
            self.shares_held -= shares_to_sell
            self.total_shares_sold += shares_to_sell
            self.total_sales_value += gross_sell_value
            self.total_commission += commission
            
            # ğŸ“Š ê±°ë˜ ìƒíƒœ ì—…ë°ì´íŠ¸
            self.trade_executed = True
            self.position = "ë§¤ë„"
            
            # ğŸ” ê²€ì¦ ê³„ì‚°
            balance_change = self.balance - old_balance
            shares_change = old_shares - self.shares_held
            
            print(f"  âœ… ë§¤ë„ ì‹¤í–‰ ê²°ê³¼:")
            print(f"    ğŸ’° ì”ê³  ë³€í™”: ${old_balance:.2f} â†’ ${self.balance:.2f} (ì¦ê°€: ${balance_change:.2f})")
            print(f"    ğŸ“ˆ ë³´ìœ ëŸ‰ ë³€í™”: {old_shares:.4f} â†’ {self.shares_held:.4f} (ê°ì†Œ: {shares_change:.4f})")
            print(f"    âœ… ì˜ˆìƒ ìˆœìˆ˜ìµ: ${net_value:.2f}")
            print(f"    âœ… ì‹¤ì œ ì”ê³  ì¦ê°€: ${balance_change:.2f}")
            
            # ğŸš¨ ê³„ì‚° ê²€ì¦
            if abs(net_value - balance_change) > 0.01:
                print(f"    ğŸš¨ ê³„ì‚° ë¶ˆì¼ì¹˜! ì˜ˆìƒ: ${net_value:.2f}, ì‹¤ì œ: ${balance_change:.2f}")
            else:
                print(f"    âœ… ê³„ì‚° ì¼ì¹˜ í™•ì¸")
                
            if abs(shares_to_sell - shares_change) > 0.0001:
                print(f"    ğŸš¨ ì£¼ì‹ ìˆ˜ëŸ‰ ë¶ˆì¼ì¹˜! ì˜ˆìƒ: {shares_to_sell:.4f}, ì‹¤ì œ: {shares_change:.4f}")
            else:
                print(f"    âœ… ì£¼ì‹ ìˆ˜ëŸ‰ ì¼ì¹˜ í™•ì¸")
        else:
            print(f"  âŒ ë§¤ë„í•  ìˆ˜ëŸ‰ì´ ì—†ìŠµë‹ˆë‹¤")

    def _get_portfolio_value(self) -> float:
        """
        ğŸ’ í˜„ì¬ í¬íŠ¸í´ë¦¬ì˜¤ ê°€ì¹˜ ê³„ì‚°
        """
        current_price = self._get_current_price()
        stock_value = self.shares_held * current_price
        total_value = self.balance + stock_value
        
        # ğŸ” ë””ë²„ê¹…ìš© ìƒì„¸ ì¶œë ¥
        if self.detailed_logging and self.current_step % 50 == 0:  # 50ìŠ¤í…ë§ˆë‹¤ ì¶œë ¥
            print(f"ğŸ’ í¬íŠ¸í´ë¦¬ì˜¤ ê°€ì¹˜ ê³„ì‚° (Step {self.current_step}):")
            print(f"  ğŸ’° í˜„ê¸ˆ: ${self.balance:.2f}")
            print(f"  ğŸ“ˆ ë³´ìœ ëŸ‰: {self.shares_held:.4f}")
            print(f"  ğŸ’µ í˜„ì¬ê°€: ${current_price:.2f}")
            print(f"  ğŸ“Š ì£¼ì‹ê°€ì¹˜: ${stock_value:.2f}")
            print(f"  ğŸ’ ì´ ê°€ì¹˜: ${total_value:.2f}")
        
        # ğŸš¨ í¬íŠ¸í´ë¦¬ì˜¤ ê°€ì¹˜ê°€ ë„ˆë¬´ ì‘ìœ¼ë©´ ìµœì†Œ ê°€ì¹˜ ë³´ì¥
        if total_value <= 0:
            return max(self.balance, 1.0)
            
        return total_value

    def _get_observation(self) -> Dict[str, np.ndarray]:
        """
        ğŸ‘€ í˜„ì¬ ê´€ì¸¡ê°’ ë°˜í™˜
        """
        # ğŸ“Š ìœˆë„ìš° í¬ê¸°ë§Œí¼ì˜ ì •ê·œí™”ëœ ê°€ê²© ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
        start_idx = max(0, self.current_step - self.window_size + 1)
        end_idx = self.current_step + 1
        
        # ğŸ”§ ë°ì´í„°ê°€ ì¶©ë¶„í•˜ì§€ ì•Šì€ ê²½ìš° íŒ¨ë”© ì²˜ë¦¬
        if start_idx == 0 and end_idx - start_idx < self.window_size:
            market_data = np.zeros((self.window_size, self.feature_dim), dtype=np.float32)
            actual_data = self.data.iloc[start_idx:end_idx].values
            market_data[-len(actual_data):] = actual_data
        else:
            market_data = self.data.iloc[start_idx:end_idx].values
            if len(market_data) < self.window_size:
                padding = np.zeros((self.window_size - len(market_data), self.feature_dim), dtype=np.float32)
                market_data = np.vstack([padding, market_data])
        
        # ğŸ’ í¬íŠ¸í´ë¦¬ì˜¤ ìƒíƒœ ê³„ì‚°
        portfolio_value = self._get_portfolio_value()
        stock_value = self.shares_held * self._get_current_price()
        
        portfolio_state = np.array([
            self.balance / portfolio_value,  # í˜„ê¸ˆ ë¹„ìœ¨
            stock_value / portfolio_value    # ì£¼ì‹ ë¹„ìœ¨
        ], dtype=np.float32)
        
        # ğŸ“Š ê´€ì¸¡ê°’ ë”•ì…”ë„ˆë¦¬ ìƒì„±
        observation = {
            'market_data': market_data.astype(np.float32),
            'portfolio_state': portfolio_state
        }
        
        self.states_history.append(observation)
        return observation

    def _calculate_reward(self, prev_portfolio_value: float, portfolio_after_trade: float, 
                         current_portfolio_value: float) -> Union[float, Dict[str, float]]:
        """
        ğŸ ë³´ìƒ ê³„ì‚° (í†µí•©ëœ ë©”ì†Œë“œ)
        """
        # ğŸ” ì•ˆì „í•œ ì´ì „ í¬íŠ¸í´ë¦¬ì˜¤ ê°’ ì„¤ì •
        if prev_portfolio_value <= 0:
            prev_portfolio_value = max(self.balance, 1.0)
        
        # ğŸ“Š ê° íš¨ê³¼ ê³„ì‚°
        if prev_portfolio_value > 0:
            trade_effect = (portfolio_after_trade - prev_portfolio_value) / prev_portfolio_value
        else:
            trade_effect = 0
            
        if portfolio_after_trade > 0:
            market_effect = (current_portfolio_value - portfolio_after_trade) / portfolio_after_trade
        else:
            market_effect = 0
            
        if prev_portfolio_value > 0:
            total_effect = (current_portfolio_value - prev_portfolio_value) / prev_portfolio_value
        else:
            total_effect = 0
        
        # ë³´ìƒ ëª¨ë“œì— ë”°ë¥¸ ê³„ì‚° í´ë¦¬í•‘
        if self.reward_mode == 'trade_only':
            reward = np.clip(trade_effect * 100, -2, 2)
        elif self.reward_mode == 'market_only':
            reward = np.clip(market_effect * 50, -5, 5)
        elif self.reward_mode == 'separated':
            trade_reward = np.clip(trade_effect * 100, -2, 2)
            market_reward = np.clip(market_effect * 50, -5, 5)
            reward = {
                'trade': trade_reward,
                'market': market_reward,
                'total': trade_reward + market_reward
            }
        else:  # 'combined'
            reward = np.clip(total_effect * 50, -5, 5)
        
        # ğŸš¨ ì˜ëª»ëœ ë§¤ë„ í˜ë„í‹°
        if self.invalid_sell_penalty:
            penalty = -1.0
            if isinstance(reward, dict):
                reward['trade'] += penalty
                reward['total'] += penalty
            else:
                reward += penalty
            print(f"âŒ ì˜ëª»ëœ ë§¤ë„ í˜ë„í‹°: {penalty}")
        
        # ğŸ“Š ìƒì„¸ ë¡œê¹…
        if self.detailed_logging:
            print(f"ğŸ ë³´ìƒ ê³„ì‚° ê²°ê³¼:")
            print(f"  ğŸ“Š ê±°ë˜ íš¨ê³¼: {trade_effect:.6f}")
            print(f"  ğŸ“ˆ ì‹œì¥ íš¨ê³¼: {market_effect:.6f}")
            print(f"  ğŸ’ ì´ íš¨ê³¼: {total_effect:.6f}")
            if isinstance(reward, dict):
                print(f"  ğŸ¯ ê±°ë˜ ë³´ìƒ: {reward['trade']:.6f}")
                print(f"  ğŸ¯ ì‹œì¥ ë³´ìƒ: {reward['market']:.6f}")
                print(f"  ğŸ¯ ì´ ë³´ìƒ: {reward['total']:.6f}")
            else:
                print(f"  ğŸ¯ ë³´ìƒ ({self.reward_mode}): {reward:.6f}")
        
        return reward

    def step(self, action: float) -> Tuple[Dict[str, np.ndarray], Union[float, Dict[str, float]], bool, Dict[str, Any]]:
        """
        ğŸš€ í™˜ê²½ì—ì„œ í•œ ìŠ¤í… ì§„í–‰ (ì •ë¦¬ëœ ë²„ì „)
        """
        print(f"\nğŸš€ Step {self.current_step} ì‹œì‘")
        print("="*60)
        
        # ğŸ”„ ì´ˆê¸°í™”
        self.invalid_sell_penalty = False
        self.actions_history.append(action)
        
        # ğŸ“Š 1. ê±°ë˜ ì „ ìƒíƒœ ì €ì¥
        current_price_before = self._get_current_price()
        prev_portfolio_value = self._get_portfolio_value()
        
        # â° ê±°ë˜ ì „ ì‹œê°„ ì •ë³´
        if self.current_step < len(self.raw_data):
            before_timestamp = self.raw_data.index[self.current_step]
        else:
            before_timestamp = "ë²”ìœ„ ì´ˆê³¼"
        
        print(f"ğŸ“… ê±°ë˜ ì „ ì‹œê°„: {before_timestamp}")
        print(f"ğŸ’µ ê±°ë˜ ì „ ê°€ê²©: ${current_price_before:.2f}")
        print(f"ğŸ’ ê±°ë˜ ì „ í¬íŠ¸í´ë¦¬ì˜¤: ${prev_portfolio_value:.2f}")
        print(f"ğŸ¯ ì—ì´ì „íŠ¸ í–‰ë™: {action:.4f}")
        
        # ğŸ”„ 2. ê±°ë˜ ì‹¤í–‰
        self._execute_trade_action(action)
        
        # ğŸ’° 3. ê±°ë˜ í›„ í¬íŠ¸í´ë¦¬ì˜¤ ê°€ì¹˜ ê³„ì‚° (ì •í™•í•œ ë°©ì‹)
        # ê±°ë˜ ì§í›„ì˜ ì‹¤ì œ ì”ê³ ì™€ ë³´ìœ ëŸ‰ì„ ê±°ë˜ ì‹œì  ê°€ê²©ìœ¼ë¡œ ê³„ì‚°
        portfolio_after_trade = self.balance + self.shares_held * current_price_before
        
        print(f"ğŸ’¼ ê±°ë˜ í›„ í¬íŠ¸í´ë¦¬ì˜¤ ê³„ì‚°:")
        print(f"  ğŸ’° ìƒˆë¡œìš´ ì”ê³ : ${self.balance:.2f}")
        print(f"  ğŸ“ˆ ìƒˆë¡œìš´ ë³´ìœ ëŸ‰: {self.shares_held:.4f}")
        print(f"  ğŸ’µ ê±°ë˜ ì‹œì  ê°€ê²©: ${current_price_before:.2f}")
        print(f"  ğŸ“Š ì£¼ì‹ ê°€ì¹˜ (ê±°ë˜ê°€ê²©): ${self.shares_held * current_price_before:.2f}")
        print(f"  ğŸ’ ê³„ì‚°ëœ í¬íŠ¸í´ë¦¬ì˜¤: ${portfolio_after_trade:.2f}")
        
        # ğŸ” ê²€ì¦: ìˆ˜ë™ìœ¼ë¡œ ë‹¤ì‹œ ê³„ì‚°í•´ë³´ê¸°
        manual_stock_value = self.shares_held * current_price_before
        manual_portfolio = self.balance + manual_stock_value
        print(f"  âœ… ê²€ì¦ ê³„ì‚°: ${self.balance:.2f} + ${manual_stock_value:.2f} = ${manual_portfolio:.2f}")
        
        if abs(portfolio_after_trade - manual_portfolio) > 0.01:
            print(f"  ğŸš¨ ê³„ì‚° ë¶ˆì¼ì¹˜ ë°œê²¬!")
        else:
            print(f"  âœ… ê³„ì‚° ì¼ì¹˜ í™•ì¸")
        
        # â° 4. ë‹¤ìŒ ìŠ¤í…ìœ¼ë¡œ ì´ë™
        self.current_step += 1
        
        # ğŸš¨ 5. ì¡°ê¸° ì¢…ë£Œ ì¡°ê±´ í™•ì¸
        if self.current_step >= len(self.raw_data):
            LOGGER.warning(f"âš ï¸ ë°ì´í„° ë²”ìœ„ ì´ˆê³¼ë¡œ ì—í”¼ì†Œë“œ ì¡°ê¸° ì¢…ë£Œ: step {self.current_step} >= data length {len(self.raw_data)}")
            done = True
            current_portfolio_value = self.balance + self.shares_held * current_price_before
            current_price_after = current_price_before
            after_timestamp = before_timestamp
        else:
            # ğŸ“ˆ 6. ì‹œì¥ ë³€ë™ í›„ í¬íŠ¸í´ë¦¬ì˜¤ ê°€ì¹˜
            current_price_after = self._get_current_price()
            current_portfolio_value = self._get_portfolio_value()
            after_timestamp = self.raw_data.index[self.current_step]
            
            # âœ… 7. ê¸°ì¡´ ì¢…ë£Œ ì¡°ê±´ í™•ì¸
            done = self.current_step >= self.data_length - 1
        
        print(f"ğŸ“… ê±°ë˜ í›„ ì‹œê°„: {after_timestamp}")
        print(f"ğŸ’µ ê±°ë˜ í›„ ê°€ê²©: ${current_price_after:.2f}")
        print(f"ğŸ’ ìµœì¢… í¬íŠ¸í´ë¦¬ì˜¤: ${current_portfolio_value:.2f}")
        print(f"ğŸ“Š ì£¼ì‹ ê°€ì¹˜ (ìƒˆ ê°€ê²©): ${self.shares_held * current_price_after:.2f}")
        print(f"ğŸ“ˆ í¬íŠ¸í´ë¦¬ì˜¤ ë³€í™”: ê±°ë˜ì „ ${prev_portfolio_value:.2f} â†’ ê±°ë˜í›„ ${portfolio_after_trade:.2f} â†’ ìµœì¢… ${current_portfolio_value:.2f}")
        
        # ğŸ” ê°€ê²© ë³€í™” íš¨ê³¼ ë¶„ì„
        price_change = current_price_after - current_price_before
        portfolio_change_from_price = self.shares_held * price_change
        print(f"ğŸ’µ ê°€ê²© ë³€í™”: ${price_change:.2f} (${current_price_before:.2f} â†’ ${current_price_after:.2f})")
        print(f"ğŸ“ˆ ê°€ê²© ë³€í™”ë¡œ ì¸í•œ í¬íŠ¸í´ë¦¬ì˜¤ ì˜í–¥: ${portfolio_change_from_price:.2f}")
        print(f"ğŸ“Š ì‹¤ì œ í¬íŠ¸í´ë¦¬ì˜¤ ë³€í™”: ${current_portfolio_value - prev_portfolio_value:.2f}")
        
        # ğŸ 8. ë³´ìƒ ê³„ì‚°
        reward = self._calculate_reward(prev_portfolio_value, portfolio_after_trade, current_portfolio_value)
        
        # ğŸ“ˆ 9. íˆìŠ¤í† ë¦¬ ì—…ë°ì´íŠ¸
        self.portfolio_values_history.append(current_portfolio_value)
        
        if isinstance(reward, dict):
            self.rewards_history.append(reward['total'])
            self.trade_effects_history.append(reward['trade'])
            self.market_effects_history.append(reward['market'])
        else:
            self.rewards_history.append(reward)
            # ê°„ë‹¨í•œ íš¨ê³¼ ê³„ì‚°í•´ì„œ ì €ì¥
            trade_effect = (portfolio_after_trade - prev_portfolio_value) / prev_portfolio_value if prev_portfolio_value > 0 else 0
            market_effect = (current_portfolio_value - portfolio_after_trade) / portfolio_after_trade if portfolio_after_trade > 0 else 0
            self.trade_effects_history.append(trade_effect)
            self.market_effects_history.append(market_effect)
        
        # ğŸ” 10. ë””ë²„ê¹… ì •ë³´ (íŠ¹ì • ìŠ¤í…ì—ì„œ)
        if self.current_step >= 340:
            print(f"\nğŸ” Step {self.current_step} ìƒì„¸ ë””ë²„ê¹…:")
            print(f"  ğŸ“Š current_step: {self.current_step}")
            print(f"  ğŸ“Š raw_data ê¸¸ì´: {len(self.raw_data)}")
            print(f"  ğŸ“Š data_length: {self.data_length}")
            print(f"  ğŸ’µ ê°€ê²© ë³€í™”: ${current_price_before:.2f} â†’ ${current_price_after:.2f}")
            print(f"  ğŸ’ í¬íŠ¸í´ë¦¬ì˜¤ ë³€í™”: ${prev_portfolio_value:.2f} â†’ ${current_portfolio_value:.2f}")
            print(f"  ğŸ ì¢…ë£Œ ì—¬ë¶€: {done}")
        
        # ğŸ‘€ 11. ê´€ì¸¡ê°’ ë° ì¶”ê°€ ì •ë³´
        observation = self._get_observation()
        info = self._get_info()
        
        # ğŸ“Š ì‹œê°„ ì •ë³´ë¥¼ infoì— ì¶”ê°€
        info.update({
            'reward_mode': self.reward_mode,
            'current_timestamp': after_timestamp,
            'previous_timestamp': before_timestamp,
            'price_before': current_price_before,
            'price_after': current_price_after,
            'portfolio_before': prev_portfolio_value,
            'portfolio_after_trade': portfolio_after_trade,
            'portfolio_after_market': current_portfolio_value
        })
        
        # ë‚™í­ ê³„ì‚° ë° ë¦¬ìŠ¤í¬ ì²´í¬
        drawdown_exceeded, daily_loss_exceeded = self._check_risk_limits(current_portfolio_value)

        if drawdown_exceeded or daily_loss_exceeded:
            done = True
            if drawdown_exceeded:
                LOGGER.warning(f"âš ï¸ ìµœëŒ€ ë‚™í­ ì´ˆê³¼ë¡œ ì—í”¼ì†Œë“œ ì¢…ë£Œ: {self.max_drawdown_pct:.2f}% > {self.max_drawdown_limit*100:.1f}%")
            if daily_loss_exceeded:
                LOGGER.warning(f"âš ï¸ ì¼ì¼ ì†ì‹¤ í•œë„ ì´ˆê³¼ë¡œ ì—í”¼ì†Œë“œ ì¢…ë£Œ: {self.max_daily_loss_pct:.2f}% > {self.max_daily_loss_limit*100:.1f}%")

        # infoì— ë¦¬ìŠ¤í¬ ì •ë³´ ì¶”ê°€
        info.update({
            'max_drawdown_pct': self.max_drawdown_pct,
            'daily_loss_pct': self.max_daily_loss_pct,
            'peak_portfolio_value': self.peak_portfolio_value,
            'risk_limit_exceeded': drawdown_exceeded or daily_loss_exceeded
        })
        print("="*60)
        return observation, reward, done, info

    def _get_info(self) -> Dict[str, Any]:
        """
        ğŸ“Š ì¶”ê°€ ì •ë³´ ë°˜í™˜
        """
        current_price = self._get_current_price()
        portfolio_value = self._get_portfolio_value()
        
        total_return = ((portfolio_value - self.initial_balance) / self.initial_balance) if self.initial_balance > 0 else 0
        
        # ğŸ“Š í¬ì§€ì…˜ ê²°ì •
        if self.trade_executed:
            position = self.position
        else:
            if self.shares_held < self.previous_shares_held:
                position = "ë§¤ë„"
            elif self.shares_held > self.previous_shares_held:
                position = "ë§¤ìˆ˜"
            else:
                position = "í™€ë“œ"
        
        self.previous_shares_held = self.shares_held
        
        # â° í˜„ì¬ íƒ€ì„ìŠ¤íƒ¬í”„ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
        current_timestamp = None
        if self.current_step < len(self.timestamps):
            current_timestamp = self.timestamps[self.current_step]
        
        timestamps_info = None
        if self.current_step < len(self.raw_data):
            timestamps_info = self.raw_data.index[self.current_step]
        
        return {
            'step': self.current_step,
            'timestamp': current_timestamp,
            'timestamps': timestamps_info,
            'balance': self.balance,
            'shares_held': self.shares_held,
            'position': position, 
            "previous_shares_held": self.previous_shares_held,
            'current_price': current_price,
            'portfolio_value': portfolio_value,
            'total_return': total_return,
            'cost_basis': self.cost_basis,
            'total_shares_purchased': self.total_shares_purchased,
            'total_shares_sold': self.total_shares_sold,
            'total_sales_value': self.total_sales_value,
            'total_commission': self.total_commission,
            'trade_executed': self.trade_executed,
        }
    
    def render(self, mode: str = 'human') -> None:
        """
        ğŸ–¥ï¸ í™˜ê²½ ì‹œê°í™”
        """
        info = self._get_info()
        
        print(f"ğŸ“Š Step: {info['step']}")
        print(f"ğŸ’° ì”ê³ : ${info['balance']:.2f}")
        print(f"ğŸ“ˆ ë³´ìœ ëŸ‰: {info['shares_held']}")
        print(f"ğŸ’µ í˜„ì¬ê°€: ${info['current_price']:.2f}")
        print(f"ğŸ’ í¬íŠ¸í´ë¦¬ì˜¤ ê°€ì¹˜: ${info['portfolio_value']:.2f}")
        print(f"ğŸ“Š ì´ ìˆ˜ìµë¥ : {info['total_return'] * 100:.2f}%")
        print(f"ğŸ’¸ ì´ ìˆ˜ìˆ˜ë£Œ: ${info['total_commission']:.2f}")
        print("-" * 50)
    
    def get_episode_data(self) -> Dict[str, List]:
        """
        ğŸ“ˆ ì—í”¼ì†Œë“œ ë°ì´í„° ë°˜í™˜
        """
        return {
            'actions': self.actions_history,
            'rewards': self.rewards_history,
            'portfolio_values': self.portfolio_values_history
        }
    
    def get_final_portfolio_value(self) -> float:
        """
        ğŸ’ ìµœì¢… í¬íŠ¸í´ë¦¬ì˜¤ ê°€ì¹˜ ë°˜í™˜
        """
        return self._get_portfolio_value()
    
    def get_total_reward(self) -> float:
        """
        ğŸ ì´ ë³´ìƒ ë°˜í™˜
        """
        return sum(self.rewards_history)
    
    def get_reward_analysis(self) -> Dict[str, Any]:
        """
        ğŸ“Š ë³´ìƒ ë¶„ì„ ê²°ê³¼ ë°˜í™˜
        """
        if not self.trade_effects_history:
            return {}
        
        trade_effects = np.array(self.trade_effects_history)
        market_effects = np.array(self.market_effects_history)
        
        return {
            'trade_effects': {
                'mean': np.mean(trade_effects),
                'std': np.std(trade_effects),
                'sum': np.sum(trade_effects),
                'positive_ratio': np.mean(trade_effects > 0)
            },
            'market_effects': {
                'mean': np.mean(market_effects),
                'std': np.std(market_effects),
                'sum': np.sum(market_effects),
                'positive_ratio': np.mean(market_effects > 0)
            },
            'correlation': np.corrcoef(trade_effects, market_effects)[0, 1] if len(trade_effects) > 1 else 0
        }
    def _check_risk_limits(self, current_portfolio_value: float) -> Tuple[bool, bool]:
        """
        ë¦¬ìŠ¤í¬ í•œë„ ì²´í¬ (ë‚™í­, ì¼ì¼ ì†ì‹¤)
        
        Returns:
            (ë‚™í­_ì´ˆê³¼_ì—¬ë¶€, ì¼ì¼ì†ì‹¤_ì´ˆê³¼_ì—¬ë¶€)
        """
        # ìµœê³  í¬íŠ¸í´ë¦¬ì˜¤ ê°€ì¹˜ ì—…ë°ì´íŠ¸
        if current_portfolio_value > self.peak_portfolio_value:
            self.peak_portfolio_value = current_portfolio_value
        
        # ìµœëŒ€ ë‚™í­ ê³„ì‚°
        current_drawdown = 0.0
        if self.peak_portfolio_value > 0:
            current_drawdown = (self.peak_portfolio_value - current_portfolio_value) / self.peak_portfolio_value
            self.max_drawdown_pct = max(self.max_drawdown_pct, current_drawdown * 100)
        
        # ì¼ì¼ ì†ì‹¤ ê³„ì‚°
        daily_loss = 0.0
        if self.daily_start_portfolio > 0:
            daily_loss = (self.daily_start_portfolio - current_portfolio_value) / self.daily_start_portfolio
            self.max_daily_loss_pct = max(self.max_daily_loss_pct, daily_loss * 100)
        
        # ë¦¬ìŠ¤í¬ í•œë„ ì²´í¬
        drawdown_exceeded = current_drawdown > self.max_drawdown_limit
        daily_loss_exceeded = daily_loss > self.max_daily_loss_limit
        
        return drawdown_exceeded, daily_loss_exceeded

    def get_risk_metrics(self) -> Dict[str, float]:
        """í˜„ì¬ ë¦¬ìŠ¤í¬ ì§€í‘œ ë°˜í™˜"""
        return {
            'max_drawdown_pct': self.max_drawdown_pct,
            'max_daily_loss_pct': self.max_daily_loss_pct,
            'peak_portfolio_value': self.peak_portfolio_value,
            'daily_start_portfolio': self.daily_start_portfolio
        }


def create_environment_from_results(results: Dict[str, Dict[str, Any]], symbol: str, data_type: str = 'test', **kwargs) -> TradingEnvironment:
    """
    ğŸ­ DataProcessor ê²°ê³¼ë¡œë¶€í„° í™˜ê²½ ìƒì„±í•˜ëŠ” í—¬í¼ í•¨ìˆ˜
    
    Args:
        results: DataProcessor.process_all_symbols()ì˜ ê²°ê³¼
        symbol: ì£¼ì‹ ì‹¬ë³¼
        data_type: 'train', 'valid', 'test' ì¤‘ í•˜ë‚˜
        **kwargs: TradingEnvironment ì¶”ê°€ ì¸ì
        
    Returns:
        TradingEnvironment ì¸ìŠ¤í„´ìŠ¤
    """
    if symbol not in results:
        raise ValueError(f"ì‹¬ë³¼ {symbol}ì„ ê²°ê³¼ì—ì„œ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤")
    
    result = results[symbol]
    
    # ğŸ“Š ì •ê·œí™”ëœ ë°ì´í„° (ì—ì´ì „íŠ¸ ê´€ì¸¡ìš©)
    if data_type not in result:
        raise ValueError(f"ë°ì´í„° íƒ€ì… {data_type}ì„ ì‹¬ë³¼ {symbol}ì—ì„œ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤")
    
    normalized_data = result[data_type]
    
    # ğŸ“ˆ ì›ë³¸ ë°ì´í„° (ì‹¤ì œ ê±°ë˜ìš©) - featured_dataì—ì„œ í•´ë‹¹ êµ¬ê°„ ì¶”ì¶œ
    featured_data = result['featured_data']
    
    if data_type == 'train':
        raw_data = featured_data.iloc[:len(normalized_data)]
    elif data_type == 'valid':
        train_len = len(result['train'])
        raw_data = featured_data.iloc[train_len:train_len + len(normalized_data)]
    else:  # test
        train_len = len(result['train'])
        valid_len = len(result['valid'])
        raw_data = featured_data.iloc[train_len + valid_len:train_len + valid_len + len(normalized_data)]
    
    print(f"ğŸ­ í™˜ê²½ ìƒì„±: {symbol} - {data_type}")
    print(f"ğŸ“Š ì •ê·œí™” ë°ì´í„°: {normalized_data.shape}")
    print(f"ğŸ“ˆ ì›ë³¸ ë°ì´í„°: {raw_data.shape}")
    
    # âœ… í™˜ê²½ ìƒì„±
    env = TradingEnvironment(
        data=normalized_data,
        raw_data=raw_data,
        symbol=symbol,
        train_data=(data_type == 'train'),
        **kwargs
    )
    
    return env    


class MultiAssetTradingEnvironment:
    """ğŸ¢ ë‹¤ì¤‘ ìì‚° íŠ¸ë ˆì´ë”© í™˜ê²½ í´ë˜ìŠ¤ (ì •ë¦¬ëœ ë²„ì „)"""
    
    def __init__(
        self,
        results: Dict[str, Dict[str, Any]],
        symbols: List[str],
        data_type: str = 'test',
        window_size: int = WINDOW_SIZE,
        initial_balance: float = INITIAL_BALANCE,
        max_trading_units: int = MAX_TRADING_UNITS,
        transaction_fee_percent: float = TRANSACTION_FEE_PERCENT,
        reward_mode: str = 'combined',
        detailed_logging: bool = True
    ):
        """
        MultiAssetTradingEnvironment í´ë˜ìŠ¤ ì´ˆê¸°í™”
        """
        self.symbols = symbols
        self.n_assets = len(symbols)
        self.data_type = data_type
        self.initial_balance = initial_balance
        
        print(f"ğŸ¢ ë‹¤ì¤‘ ìì‚° í™˜ê²½ ì´ˆê¸°í™”: {self.n_assets}ê°œ ìì‚°")
        
        # ğŸ­ ê°œë³„ í™˜ê²½ ìƒì„±
        self.envs = {}
        for symbol in symbols:
            print(f"ğŸ“Š {symbol} í™˜ê²½ ìƒì„± ì¤‘...")
            self.envs[symbol] = create_environment_from_results(
                results=results,
                symbol=symbol,
                data_type=data_type,
                window_size=window_size,
                initial_balance=initial_balance / self.n_assets,  # ìì‚°ë³„ ê· ë“± ë°°ë¶„
                max_trading_units=max_trading_units,
                transaction_fee_percent=transaction_fee_percent,
                reward_mode=reward_mode,
                detailed_logging=detailed_logging
            )
        
        # ğŸ® í–‰ë™ ê³µê°„: ê° ìì‚°ì— ëŒ€í•œ ì—°ì† í–‰ë™
        self.action_space = spaces.Box(
            low=-1.0, high=1.0, shape=(self.n_assets,), dtype=np.float32
        )
        
        # ğŸ‘€ ê´€ì¸¡ ê³µê°„
        self.observation_space = spaces.Dict({
            symbol: env.observation_space for symbol, env in self.envs.items()
        })
        
        LOGGER.info(f"âœ… ë‹¤ì¤‘ ìì‚° í™˜ê²½ ì´ˆê¸°í™” ì™„ë£Œ: {self.n_assets}ê°œ ìì‚°, {data_type} ë°ì´í„°")

    def reset(self) -> Dict[str, Dict[str, np.ndarray]]:
        """
        ğŸ”„ í™˜ê²½ ì´ˆê¸°í™”
        """
        print(f"ğŸ”„ ë‹¤ì¤‘ ìì‚° í™˜ê²½ ë¦¬ì…‹")
        observations = {}
        for symbol, env in self.envs.items():
            observations[symbol] = env.reset()
        
        return observations
    
    def step(self, actions: Dict[str, float]) -> Tuple[Dict[str, Dict[str, np.ndarray]], float, bool, Dict[str, Any]]:
        """
        ğŸš€ í™˜ê²½ì—ì„œ í•œ ìŠ¤í… ì§„í–‰
        
        Args:
            actions: ì‹¬ë³¼ì„ í‚¤ë¡œ í•˜ê³  í–‰ë™ì„ ê°’ìœ¼ë¡œ í•˜ëŠ” ë”•ì…”ë„ˆë¦¬
            
        Returns:
            (ê´€ì¸¡ê°’, ë³´ìƒ, ì¢…ë£Œ ì—¬ë¶€, ì¶”ê°€ ì •ë³´) íŠœí”Œ
        """
        observations = {}
        rewards = {}
        dones = {}
        infos = {}
        
        print(f"\nğŸš€ ë‹¤ì¤‘ ìì‚° Step ì§„í–‰")
        
        # ğŸ“Š ê° ìì‚°ì— ëŒ€í•œ í–‰ë™ ì‹¤í–‰
        for symbol, env in self.envs.items():
            action = actions.get(symbol, 0.0)  # í–‰ë™ì´ ì—†ëŠ” ê²½ìš° í™€ë“œ
            print(f"ğŸ“ˆ {symbol} ì²˜ë¦¬ ì¤‘...")
            obs, rew, done, info = env.step(action)
            
            observations[symbol] = obs
            rewards[symbol] = rew
            dones[symbol] = done
            infos[symbol] = info
        
        # ğŸ ì „ì²´ ë³´ìƒì€ ê° ìì‚°ì˜ ë³´ìƒ í‰ê· 
        total_reward = sum(rewards.values()) / self.n_assets
        
        # ğŸ ëª¨ë“  ìì‚°ì˜ ì—í”¼ì†Œë“œê°€ ì¢…ë£Œë˜ë©´ ì „ì²´ ì—í”¼ì†Œë“œ ì¢…ë£Œ
        done = all(dones.values())
        
        # ğŸ’ ì „ì²´ í¬íŠ¸í´ë¦¬ì˜¤ ê°€ì¹˜ ê³„ì‚°
        total_portfolio_value = sum(info['portfolio_value'] for info in infos.values())
        trade_executed_any = any(info.get('trade_executed', False) for info in infos.values())
        
        # ğŸ“Š ì¶”ê°€ ì •ë³´ì— ì „ì²´ í¬íŠ¸í´ë¦¬ì˜¤ ê°€ì¹˜ í¬í•¨
        infos['total'] = {
            'portfolio_value': total_portfolio_value,
            'total_return': (total_portfolio_value - self.initial_balance) / self.initial_balance,
            'trade_executed': trade_executed_any
        }

        return observations, total_reward, done, infos
    
    def render(self, mode: str = 'human') -> None:
        """
        ğŸ–¥ï¸ í™˜ê²½ ì‹œê°í™”
        """
        total_portfolio_value = 0
        
        print("=" * 50)
        print("ğŸ¢ ë‹¤ì¤‘ ìì‚° íŠ¸ë ˆì´ë”© í™˜ê²½ ìƒíƒœ")
        print("=" * 50)
        
        for symbol, env in self.envs.items():
            info = env._get_info()
            total_portfolio_value += info['portfolio_value']
            
            print(f"ğŸ“ˆ ìì‚°: {symbol}")
            print(f"  ğŸ’µ ê°€ê²©: ${info['current_price']:.2f}")
            print(f"  ğŸ“Š ë³´ìœ ëŸ‰: {info['shares_held']:.3f}")
            print(f"  ğŸ’ í¬íŠ¸í´ë¦¬ì˜¤ ê°€ì¹˜: ${info['portfolio_value']:.2f}")
            print(f"  ğŸ“Š ìˆ˜ìµë¥ : {info['total_return'] * 100:.2f}%")
            print("-" * 50)
        
        total_return = (total_portfolio_value - self.initial_balance) / self.initial_balance
        print(f"ğŸ’ ì´ í¬íŠ¸í´ë¦¬ì˜¤ ê°€ì¹˜: ${total_portfolio_value:.2f}")
        print(f"ğŸ“Š ì´ ìˆ˜ìµë¥ : {total_return * 100:.2f}%")
        print("=" * 50)
    
    def get_final_portfolio_value(self) -> float:
        """
        ğŸ’ ìµœì¢… í¬íŠ¸í´ë¦¬ì˜¤ ê°€ì¹˜ ë°˜í™˜
        """
        return sum(env.get_final_portfolio_value() for env in self.envs.values())
    
    def get_total_reward(self) -> float:
        """
        ğŸ ì´ ë³´ìƒ ë°˜í™˜
        """
        return sum(env.get_total_reward() for env in self.envs.values()) / self.n_assets


def create_flexible_environment(results, symbol, reward_mode='combined', detailed_logging=True, data_type='train'):
    """
    ğŸ”§ ìœ ì—°í•œ ë³´ìƒ ì‹œìŠ¤í…œì„ ê°€ì§„ í™˜ê²½ ìƒì„±
    
    Args:
        results: DataProcessor ê²°ê³¼
        symbol: ì£¼ì‹ ì‹¬ë³¼
        reward_mode: 'combined', 'trade_only', 'market_only', 'separated'
        detailed_logging: ìƒì„¸ ë¡œê¹… ì—¬ë¶€
        data_type: 'train', 'valid', 'test'
    """
    print(f"ğŸ”§ ìœ ì—°í•œ í™˜ê²½ ìƒì„±: {symbol} - {reward_mode}")
    env = create_environment_from_results(
        results=results,
        symbol=symbol,
        data_type=data_type,
        reward_mode=reward_mode,
        detailed_logging=detailed_logging
    )
    return env


if __name__ == "__main__":
    # ğŸ§ª ëª¨ë“ˆ í…ŒìŠ¤íŠ¸ ì½”ë“œ
    import matplotlib.pyplot as plt
    from src.data_collection.data_collector import DataCollector
    from src.preprocessing.data_processor import DataProcessor
    from src.config.config import config
    import argparse
    
    parser = argparse.ArgumentParser(description="í…ŒìŠ¤íŠ¸í•  ì‹¬ë³¼")
    parser.add_argument("--symbols", nargs="+", help="í…ŒìŠ¤íŠ¸í•  ì‹¬ë³¼ ë¦¬ìŠ¤íŠ¸", default=config.trading_symbols)
    args = parser.parse_args()
    
    # ğŸ“Š ì‹¬ë³¼ ë¦¬ìŠ¤íŠ¸ í• ë‹¹
    symbols = args.symbols
    TARGET_SYMBOL = symbols[0] if symbols else config.trading_symbols
    print(f'ğŸ“ˆ í…ŒìŠ¤íŠ¸ ì‹¬ë³¼ë“¤: {symbols}')
    print(f'ğŸ¯ ì£¼ìš” í…ŒìŠ¤íŠ¸ ì‹¬ë³¼: {TARGET_SYMBOL}')
    
    # ğŸ“Š ë°ì´í„° ìˆ˜ì§‘ ë° ì „ì²˜ë¦¬
    print("ğŸ“Š ë°ì´í„° ìˆ˜ì§‘ ì‹œì‘...")
    collector = DataCollector(symbols=symbols)
    data = collector.load_all_data()
    
    try:
        if data:
            print("ğŸ”„ ë°ì´í„° ì „ì²˜ë¦¬ ì‹œì‘...")
            processor = DataProcessor()
            results = processor.process_all_symbols(data)
            
            if TARGET_SYMBOL in results:
                print("=" * 60)
                print(f"ğŸ§ª ì •ë¦¬ëœ TradingEnvironment í…ŒìŠ¤íŠ¸ ì‹œì‘ - {TARGET_SYMBOL}")
                print("=" * 60)
                
                # ğŸ¯ ë‹¤ì–‘í•œ ë³´ìƒ ëª¨ë“œë¡œ í…ŒìŠ¤íŠ¸
                for reward_mode in ['combined', 'trade_only', 'market_only', 'separated']:
                    print(f"\nğŸ”„ ë³´ìƒ ëª¨ë“œ í…ŒìŠ¤íŠ¸: {reward_mode}")
                    print("-" * 40)
                    
                    # âœ… ìƒˆë¡œìš´ ë°©ì‹ìœ¼ë¡œ í™˜ê²½ ìƒì„±
                    env = create_flexible_environment(
                        results=results,
                        symbol=TARGET_SYMBOL,
                        reward_mode=reward_mode,
                        detailed_logging=False,  # í…ŒìŠ¤íŠ¸ì—ì„œëŠ” ê°„ë‹¨íˆ
                        data_type='train'
                    )
                    
                    print(f"âœ… í™˜ê²½ ìƒì„± ì™„ë£Œ: {env.symbol}")
                    print(f"ğŸ¯ ë³´ìƒ ëª¨ë“œ: {env.reward_mode}")
                    
                    # ğŸ§ª ê°„ë‹¨í•œ í…ŒìŠ¤íŠ¸
                    obs = env.reset()
                    
                    # ğŸš€ 5ìŠ¤í… ì‹¤í–‰
                    total_reward = 0
                    for i in range(5):
                        action = np.random.uniform(-1.0, 1.0)
                        obs, reward, done, info = env.step(action)
                        
                        if isinstance(reward, dict):
                            total_reward += reward['total']
                            print(f"  Step {i+1}: ê±°ë˜ë³´ìƒ={reward['trade']:.6f}, ì‹œì¥ë³´ìƒ={reward['market']:.6f}, ì´ë³´ìƒ={reward['total']:.6f}")
                        else:
                            total_reward += reward
                            print(f"  Step {i+1}: ë³´ìƒ={reward:.6f}")
                        
                        if done:
                            break
                    
                    print(f"  ğŸ ì´ ë³´ìƒ: {total_reward:.6f}")
                    
                    # ğŸ“Š ë³´ìƒ ë¶„ì„
                    analysis = env.get_reward_analysis()
                    if analysis:
                        print(f"  ğŸ“Š ê±°ë˜ íš¨ê³¼ í‰ê· : {analysis['trade_effects']['mean']:.6f}")
                        print(f"  ğŸ“ˆ ì‹œì¥ íš¨ê³¼ í‰ê· : {analysis['market_effects']['mean']:.6f}")
                
                print("\n" + "=" * 60)
                print("âœ… ëª¨ë“  í…ŒìŠ¤íŠ¸ ì™„ë£Œ!")
                print("=" * 60)
                
            else:
                print(f"âŒ {TARGET_SYMBOL} ë°ì´í„°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
                print(f"âœ… ì‚¬ìš© ê°€ëŠ¥í•œ ì‹¬ë³¼: {list(results.keys())}")
        else:
            print("âŒ ë°ì´í„°ë¥¼ ë¡œë“œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
            
    except Exception as e:
        print(f"ğŸš¨ í…ŒìŠ¤íŠ¸ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
        import traceback
        traceback.print_exc()


def check_time_continuity(env):
    """
    â° ì‹œê°„ ë°ì´í„° ì—°ì†ì„± í™•ì¸ í•¨ìˆ˜
    """
    print(f"\nâ° ì‹œê°„ ë°ì´í„° ì—°ì†ì„± í™•ì¸ (340-360 ìŠ¤í…)")
    print("="*80)
    
    for i in range(340, min(360, len(env.raw_data))):
        timestamp = env.raw_data.index[i]
        price = env.raw_data.iloc[i]['close'] if 'close' in env.raw_data.columns else env.raw_data.iloc[i][-1]
        
        print(f"Step {i:3d}: {timestamp} | ${price:8.2f}")
        
        # â° ì‹œê°„ ê°„ê²© ì²´í¬
        if i > 340:
            prev_timestamp = env.raw_data.index[i-1]
            try:
                time_diff = timestamp - prev_timestamp
                if time_diff.total_seconds() == 0:
                    print(f"         âš ï¸ ë™ì¼í•œ ì‹œê°„!")
                elif time_diff.total_seconds() < 0:
                    print(f"         ğŸš¨ ì‹œê°„ì´ ê±°ê¾¸ë¡œ!")
                else:
                    print(f"         âœ… ê°„ê²©: {time_diff}")
            except:
                print(f"         â“ ì‹œê°„ ë¹„êµ ë¶ˆê°€")